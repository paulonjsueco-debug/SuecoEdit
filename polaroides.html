<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SuecoEdit - Polaroides</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="favicon.png">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- jsPDF CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Caveat+Brush&family=Cinzel:wght@400..900&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        @font-face {
            font-family: 'Valentine Baby';
            src: url('https://fonts.cdnfonts.com/s/72225/Valentine Baby.woff') format('woff');
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 14px 0 rgba(0, 0, 0, 0.2);
            background-color: #f3f4f6;
        }

        .hero-section {
            background: linear-gradient(135deg, #60a5fa, #3b82f6);
            color: white;
            padding: 2rem 1rem;
            text-align: center;
            border-bottom-left-radius: 2rem;
            border-bottom-right-radius: 2rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 14px 0 rgba(0, 0, 0, 0.2);
        }

        .hero-section h1 {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
        }

        .hero-section p {
            font-size: 1rem;
            opacity: 0.9;
        }

        .container-wrapper {
            max-width: 100%;
            padding: 0.5rem;
        }
        
        /* Estilos do Editor de Imagens */
        .container {
            max-width: 960px;
        }
        .file-input-label {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .file-input-label:hover {
            background-color: #2563eb;
        }
        .editor-container {
            position: relative;
            user-select: none;
            overflow: hidden;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f3f4f6;
        }
        
        /* Novos estilos para a visualização com máscara e linhas */
        .mask-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .mask-line {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.6);
            z-index: 11;
        }
        
        .mask-line.vertical {
            width: 1px;
            height: 100%;
        }
        
        .mask-line.horizontal {
            width: 100%;
            height: 1px;
        }
        
        .preview-canvas-wrapper {
            position: relative;
            user-select: none;
            overflow: hidden;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #fff;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            margin: 0.5rem;
        }
        .preview-zoom-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 12px;
        }

        /* Carousel Styles */
        .carousel-container {
            position: relative;
            overflow: hidden;
            max-width: 700px;
            margin: 0 auto 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 4px 14px 0 rgba(0, 0, 0, 0.1);
            height: 120px;
        }
        .carousel-slide-wrapper {
            display: flex;
            transition: transform 0.5s ease;
            height: 100%;
        }
        .carousel-slide {
            min-width: 100%;
            flex-shrink: 0;
            padding: 1rem;
            text-align: center;
            background-color: #ffffff;
            border-radius: 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .carousel-dot {
            height: 10px;
            width: 10px;
            background-color: #bbb;
            border-radius: 50%;
            display: inline-block;
            transition: background-color 0.6s ease;
            margin: 0 3px;
            cursor: pointer;
        }
        .active-dot {
            background-color: #3b82f6;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .spinner {
            animation: spin 1s linear infinite;
        }

        /* Full Preview Area - MODIFICADO para grade 2x4 */
        #full-preview-area {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 1rem;
            overflow-y: auto;
            align-items: start;
            justify-items: center;
            max-height: 70vh;
        }
        
        #full-preview-area .preview-page {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        /* Novos estilos para melhorias */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            flex-direction: column;
        }
        
        .image-card {
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .image-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        
        .tooltip {
            position: relative;
        }
        
        .tooltip .tooltip-text {
            visibility: hidden;
            width: 120px;
            background-color: black;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* Preview em tempo real para controles */
        .realtime-preview {
            transition: all 0.3s ease;
        }
        
        /* Estilos para mobile */
        @media (max-width: 768px) {
            .hero-section {
                padding: 1.5rem 1rem;
            }
            
            .hero-section h1 {
                font-size: 1.5rem;
            }
            
            .container {
                padding: 1rem;
            }
            
            .flex-row-mobile {
                flex-direction: column;
            }
            
            .button-mobile {
                width: 100%;
                margin-bottom: 0.5rem;
            }
            
            /* Ajustes para o modal em mobile */
            #edit-modal > div {
                width: 95%;
                height: 90%;
                padding: 1rem;
            }
            
            .tool-btn {
                font-size: 0.8rem;
                padding: 0.5rem;
            }
            
            /* Ajustes para a pré-visualização em mobile */
            #full-preview-area {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(4, 1fr);
            }
        }
        
        /* Melhorias de acessibilidade */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        /* Melhorias para os controles de legenda */
        .caption-preview {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Manter proporção da imagem */
        .maintain-aspect-ratio {
            object-fit: contain;
        }
        
        /* Estilos para a área de upload com drag and drop */
        .drag-over {
            background-color: #dbeafe !important;
            border-color: #3b82f6 !important;
        }
        
        /* Estilos para os controles de zoom */
        .zoom-controls {
            transition: all 0.3s ease;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="flex items-center gap-3 p-4 bg-white shadow-md">
        <img src="favicon.png" alt="Logo" class="w-8 h-8">
        <h1 class="text-xl font-bold text-gray-700">SuecoEdit</h1>
    </div>
    
    <!-- Início do código da aplicação SuecoEdit -->
    <div class="container mx-auto px-4 py-6">
        <!-- Título -->
        <div class="text-center mb-8">
            <h2 class="text-3xl font-bold text-blue-800">Criar Fotos Polaroides</h2>
            <p class="text-gray-600 mt-2">Arraste e solte fotos para criar fotos polaroides com uma grade de 2x4.</p>
        </div>

        <!-- Seção de Upload com Drag & Drop -->
        <div id="upload-section" class="mt-6 mb-6 p-8 border-2 border-dashed border-gray-300 rounded-xl text-center bg-white transition-colors duration-300">
            <div class="flex flex-col items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
                <p class="text-lg font-medium text-gray-700 mb-2">Arraste e solte suas imagens aqui</p>
                <p class="text-sm text-gray-500 mb-4">ou</p>
                <label for="image-upload" class="file-input-label bg-blue-500 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-blue-600 transition-colors inline-block cursor-pointer">
                    <span>Selecionar Imagens</span>
                    <input type="file" id="image-upload" accept="image/*" multiple class="hidden">
                </label>
                <p class="text-xs text-gray-400 mt-4">Suporte a JPEG e PNG. Máx. 10MB por imagem.</p>
            </div>
        </div>

        <!-- Controles do layout de imagens -->
        <div class="flex flex-col sm:flex-row justify-between items-center mb-6 gap-4">
            <h2 class="text-xl font-bold text-gray-800">Imagens Carregadas</h2>
            <button id="clear-all-btn" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-red-600 transition-colors transform hover:scale-105 w-full sm:w-auto">
                Limpar Tudo
            </button>
        </div>

        <!-- Galeria de miniaturas de imagens -->
        <div id="image-gallery" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 mb-8">
            <!-- As miniaturas serão adicionadas aqui via JavaScript -->
        </div>

        <!-- Controles e Opções -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <div class="p-6 bg-white rounded-xl shadow-md">
                <h2 class="text-lg font-bold mb-4 text-blue-800">Opções de Layout</h2>
                <div class="flex flex-col space-y-3">
                    <p class="text-gray-700 text-sm">O layout das fotos está fixo em uma grade de 2x4 (duas linhas, quatro colunas) com espaçamento otimizado.</p>
                </div>
            </div>

            <!-- Visualização da Folha A4 em Mosaico -->
            <div class="p-6 bg-white rounded-xl shadow-md">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-bold text-blue-800">Pré-visualização</h2>
                </div>
                <div id="preview-gallery" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <!-- O mosaico de pré-visualizações será adicionado aqui via JavaScript -->
                </div>
            </div>
        </div>

        <!-- Botões de Exportar e Pré-visualização -->
        <div class="flex flex-col md:flex-row flex-wrap justify-center gap-4 mt-8">
            <button id="full-preview-btn" class="bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg hover:bg-indigo-600 transition-colors transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed w-full sm:w-auto tooltip">
                Pré-visualização de Exportação
                <span class="tooltip-text">Visualizar todas as páginas antes de exportar</span>
            </button>
            <div class="flex flex-wrap justify-center gap-4">
                <button id="export-landscape-btn" class="bg-blue-500 text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg hover:bg-blue-600 transition-colors transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed w-full sm:w-auto tooltip">
                    Gerar PDF
                    <span class="tooltip-text">Exportar em formato PDF no modo paisagem</span>
                </button>
                <button id="export-landscape-jpg-btn" class="bg-green-500 text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg hover:bg-green-600 transition-colors transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed w-full sm:w-auto tooltip">
                    Gerar JPG
                    <span class="tooltip-text">Exportar em formato JPG no modo paisagem</span>
                </button>
            </div>
        </div>
        <div id="status-message" class="mt-4 text-center text-gray-600 font-medium"></div>
        
        <!-- Loading Overlay -->
        <div id="loading-overlay" class="loading-overlay hidden">
            <div class="spinner mb-3">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            </div>
            <p id="loading-text">Processando...</p>
        </div>
    </div>

    <!-- Modal de Edição -->
    <div id="edit-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center p-2 sm:p-4 z-50">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-5xl h-full p-2 sm:p-6 transform transition-transform duration-300 flex flex-col">
            <!-- Área Principal de Edição e Painel de Ferramentas -->
            <div class="flex-1 flex flex-col lg:flex-row overflow-hidden p-2 sm:p-0">
                <!-- Área Principal do Canvas -->
                <div class="flex-1 flex items-center justify-center relative min-h-[30vh] lg:min-h-96">
                    <div id="editor-area" class="editor-container w-full h-full relative">
                        <canvas id="editor-canvas" class="w-full h-full maintain-aspect-ratio"></canvas>
                        <!-- Overlay com máscara e linhas tracejadas -->
                        <div id="mask-overlay" class="mask-overlay">
                            <!-- Linhas serão adicionadas via JavaScript -->
                        </div>
                    </div>
                </div>

                <!-- Painel de Controles da Ferramenta -->
                <div id="tool-controls-container" class="w-full lg:w-96 flex-shrink-0 lg:ml-6 mt-4 lg:mt-0 p-2 border-t lg:border-t-0 lg:border-l border-gray-200 overflow-y-auto">
                    <!-- Controles da Ferramenta de Zoom -->
                    <div id="zoom-controls" class="hidden">
                        <h3 class="text-xl font-bold mb-2 text-center lg:text-left">Ajustar Zoom</h3>
                        <p class="text-sm text-gray-600 mb-4 text-center lg:text-left">Ajuste o zoom para enquadrar a imagem como desejar.</p>
                        
                        <div class="flex items-center justify-between mb-4">
                            <button id="zoom-out-btn" class="zoom-btn bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition-colors">
                                -
                            </button>
                            
                            <div class="flex-1 mx-4">
                                <input type="range" id="zoom-slider" min="50" max="300" value="100" class="w-full accent-blue-500 realtime-preview">
                                <div class="flex justify-between text-xs text-gray-500 mt-1">
                                    <span>50%</span>
                                    <span id="zoom-value">100%</span>
                                    <span>300%</span>
                                </div>
                            </div>
                            
                            <button id="zoom-in-btn" class="zoom-btn bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition-colors">
                                +
                            </button>
                        </div>
                        
                        <div class="flex justify-center space-x-2 mb-4">
                            <button id="zoom-reset-btn" class="bg-gray-200 text-gray-700 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition-colors">
                                Redefinir
                            </button>
                        </div>
                        
                        <div class="flex justify-center lg:justify-end space-x-4 mt-4">
                            <button id="discard-zoom-btn" class="bg-gray-400 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-gray-500 transition-colors">
                                Descartar Alterações
                            </button>
                            <button id="save-zoom-btn" class="bg-blue-500 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-blue-600 transition-colors">
                                Salvar Alterações
                            </button>
                        </div>
                    </div>

                    <!-- Controles da Ferramenta de Legenda -->
                    <div id="caption-controls" class="hidden">
                        <h3 class="text-xl font-bold mb-2 text-center lg:text-left">Ajustar Legenda</h3>
                        <div class="flex flex-wrap -mx-2 mb-4">
                            <div class="px-2 w-full mb-4">
                                <label class="block">
                                    <span class="text-gray-700">Texto:</span>
                                    <input type="text" id="caption-text-input" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 realtime-preview">
                                </label>
                            </div>
                            <div class="px-2 w-1/2 mb-4">
                                <label class="block">
                                    <span class="text-gray-700">Cor:</span>
                                    <input type="color" id="caption-color-input" class="mt-1 block w-full h-10 rounded-md border-gray-300 realtime-preview" value="#000000">
                                </label>
                            </div>
                            <div class="px-2 w-1/2 mb-4">
                                <label class="block">
                                    <span class="text-gray-700">Contorno:</span>
                                    <input type="color" id="caption-outline-color-input" class="mt-1 block w-full h-10 rounded-md border-gray-300 realtime-preview" value="#FFFFFF">
                                </label>
                            </div>
                            <div class="px-2 w-full mb-4">
                                <label class="block">
                                    <span class="text-gray-700">Tamanho da Fonte:</span>
                                    <input type="range" id="caption-size-slider" min="10" max="100" value="20" class="mt-1 w-full accent-blue-500 realtime-preview">
                                    <p class="text-right text-sm text-gray-500" id="caption-size-value">20 px</p>
                                </label>
                            </div>
                            <div class="px-2 w-full mb-4">
                                <label class="block">
                                    <span class="text-gray-700">Espessura do Contorno:</span>
                                    <input type="range" id="caption-stroke-slider" min="0" max="100" value="0" class="mt-1 w-full accent-blue-500 realtime-preview">
                                    <p class="text-right text-sm text-gray-500" id="caption-stroke-value">0 px</p>
                                </label>
                            </div>
                            <div class="px-2 w-full mb-4">
                                <label class="block">
                                    <span class="text-gray-700">Fonte:</span>
                                    <select id="caption-font-select" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm realtime-preview">
                                        <option value="Valentine Baby, sans-serif">Valentine Baby</option>
                                        <option value="Inter, sans-serif">Inter</option>
                                        <option value="Arial, sans-serif">Arial</option>
                                        <option value="Verdana, sans-serif">Verdana</option>
                                        <option value="Times New Roman, serif">Times New Roman</option>
                                        <option value="Courier New, monospace">Courier New</option>
                                    </select>
                                </label>
                            </div>
                        </div>
                        <div class="flex justify-center lg:justify-end space-x-4 mt-4">
                            <button id="discard-caption-btn" class="bg-gray-400 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-gray-500 transition-colors">
                                Descartar Alterações
                            </button>
                            <button id="save-caption-btn" class="bg-blue-500 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-blue-600 transition-colors">
                                Salvar Alterações
                            </button>
                        </div>
                    </div>

                    <!-- Controles de Edição de Fundo -->
                    <div id="background-controls" class="hidden">
                        <h3 class="text-xl font-bold mb-2 text-center lg:text-left">Editar Fundo</h3>
                        <p class="text-sm text-gray-600 mb-4 text-center lg:text-left">Ajuste o desfoque e o redimensionamento do fundo da imagem.</p>
                        <label class="block mb-4">
                            <span class="text-gray-700">Intensidade do Desfoque:</span>
                            <input type="range" id="blur-slider" min="0" max="250" value="15" class="mt-1 w-full accent-indigo-500 realtime-preview">
                            <p class="text-right text-sm text-gray-500" id="blur-value">15 px</p>
                        </label>
                        <label class="block mb-4">
                            <span class="text-gray-700">Redimensionar Fundo (%):</span>
                            <input type="range" id="background-size-slider" min="100" max="500" value="100" class="mt-1 w-full accent-indigo-500 realtime-preview">
                            <p class="text-right text-sm text-gray-500" id="background-size-value">100 %</p>
                        </label>
                        <div class="flex justify-center lg:justify-end space-x-4 mt-4">
                            <button id="discard-background-btn" class="bg-gray-400 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-gray-500 transition-colors">
                                Descartar Alterações
                            </button>
                            <button id="save-background-btn" class="bg-blue-500 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-blue-600 transition-colors">
                                Salvar Alterações
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Botões de Ação do Modal - Fundo do painel de edição -->
            <div class="flex flex-col lg:flex-row justify-between items-center space-y-4 lg:space-y-0 lg:space-x-4 mt-6 border-t pt-4 border-gray-200">
                <button id="back-btn" class="bg-blue-400 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-blue-500 transition-colors w-full lg:w-auto">
                    Voltar
                </button>
                <div class="flex flex-wrap justify-center lg:justify-end gap-2 w-full lg:w-auto">
                    <button id="tool-zoom-btn" class="tool-btn bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors flex-1">
                        Zoom
                    </button>
                    <button id="tool-caption-btn" class="tool-btn bg-gray-200 text-gray-700 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition-colors flex-1">
                        Adicionar Legenda
                    </button>
                    <button id="tool-background-btn" class="tool-btn bg-gray-200 text-gray-700 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition-colors flex-1">
                        Editar Fundo
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Novo Modal de Pré-visualização de Exportação -->
    <div id="full-preview-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center p-2 sm:p-4 z-50">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-5xl h-full p-2 sm:p-6 transform transition-transform duration-300 flex flex-col">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-2xl font-bold">Pré-visualização de Exportação</h2>
                <button id="close-preview-btn" class="bg-gray-400 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-gray-500 transition-colors">
                    Fechar
                </button>
            </div>

            <!-- Controles de navegação do carrossel -->
            <div id="full-preview-nav" class="flex justify-between items-center mb-4">
                <button id="prev-page-btn" class="bg-gray-200 text-gray-800 p-2 rounded-full hover:bg-gray-300 disabled:opacity-50 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                    </svg>
                </button>
                <span id="page-indicator" class="text-xl font-bold text-gray-700"></span>
                <button id="next-page-btn" class="bg-gray-200 text-gray-800 p-2 rounded-full hover:bg-gray-300 disabled:opacity-50 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                </button>
            </div>

            <!-- MODIFICADO: Área de pré-visualização em grade 2x4 -->
            <div id="full-preview-area" class="grid grid-cols-2 gap-4 overflow-y-auto">
                <!-- As imagens de pré-visualização serão adicionadas aqui via JavaScript -->
            </div>
            
            <div class="flex flex-col md:flex-row flex-wrap justify-center gap-4 mt-8 border-t pt-4">
                <div class="flex flex-wrap justify-center gap-4">
                    <button id="modal-export-landscape-btn" class="bg-blue-500 text-white font-bold py-4 px-10 rounded-lg text-xl shadow-lg hover:bg-blue-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed">
                        Gerar PDF
                    </button>
                    <button id="modal-export-landscape-jpg-btn" class="bg-green-500 text-white font-bold py-4 px-10 rounded-lg text-xl shadow-lg hover:bg-green-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed">
                        Gerar JPG
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Main application script
        window.onload = function() {
            const { jsPDF } = window.jspdf;

            const imageUpload = document.getElementById('image-upload');
            const imageGallery = document.getElementById('image-gallery');
            const clearAllBtn = document.getElementById('clear-all-btn');
            const exportLandscapeBtn = document.getElementById('export-landscape-btn');
            const exportLandscapeJpgBtn = document.getElementById('export-landscape-jpg-btn');
            const statusMessage = document.getElementById('status-message');
            const previewGallery = document.getElementById('preview-gallery');
            const editModal = document.getElementById('edit-modal');
            const backBtn = document.getElementById('back-btn');
            const editorCanvas = document.getElementById('editor-canvas');
            const toolZoomBtn = document.getElementById('tool-zoom-btn');
            const toolCaptionBtn = document.getElementById('tool-caption-btn');
            const toolBackgroundBtn = document.getElementById('tool-background-btn');
            const zoomControls = document.getElementById('zoom-controls');
            const captionControls = document.getElementById('caption-controls');
            const backgroundControls = document.getElementById('background-controls');
            const maskOverlay = document.getElementById('mask-overlay');
            const zoomSlider = document.getElementById('zoom-slider');
            const zoomValue = document.getElementById('zoom-value');
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const zoomResetBtn = document.getElementById('zoom-reset-btn');
            const saveZoomBtn = document.getElementById('save-zoom-btn');
            const discardZoomBtn = document.getElementById('discard-zoom-btn');
            const captionTextInput = document.getElementById('caption-text-input');
            const captionColorInput = document.getElementById('caption-color-input');
            const captionOutlineColorInput = document.getElementById('caption-outline-color-input');
            const captionSizeSlider = document.getElementById('caption-size-slider');
            const captionSizeValueText = document.getElementById('caption-size-value');
            const captionStrokeSlider = document.getElementById('caption-stroke-slider');
            const captionStrokeValueText = document.getElementById('caption-stroke-value');
            const captionFontSelect = document.getElementById('caption-font-select');
            const blurSlider = document.getElementById('blur-slider');
            const blurValueText = document.getElementById('blur-value');
            const backgroundSizeSlider = document.getElementById('background-size-slider');
            const backgroundSizeValueText = document.getElementById('background-size-value');
            const editorArea = document.getElementById('editor-area');
            const uploadSection = document.getElementById('upload-section');
            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingText = document.getElementById('loading-text');

            // Novos botões e modais de pré-visualização
            const fullPreviewBtn = document.getElementById('full-preview-btn');
            const fullPreviewModal = document.getElementById('full-preview-modal');
            const closePreviewBtn = document.getElementById('close-preview-btn');
            const fullPreviewArea = document.getElementById('full-preview-area');
            const modalExportLandscapeBtn = document.getElementById('modal-export-landscape-btn');
            const modalExportLandscapeJpgBtn = document.getElementById('modal-export-landscape-jpg-btn');
            
            // Novos elementos de navegação
            const fullPreviewNav = document.getElementById('full-preview-nav');
            const prevPageBtn = document.getElementById('prev-page-btn');
            const nextPageBtn = document.getElementById('next-page-btn');
            const pageIndicator = document.getElementById('page-indicator');
            let currentPageIndex = 0;

            // New save/discard buttons for each tool
            const saveCaptionBtn = document.getElementById('save-caption-btn');
            const discardCaptionBtn = document.getElementById('discard-caption-btn');
            const saveBackgroundBtn = document.getElementById('save-background-btn');
            const discardBackgroundBtn = document.getElementById('discard-background-btn');

            const editorCtx = editorCanvas.getContext('2d');

            let uploadedImages = [];
            let currentImageIndex = -1;
            let currentTool = null;
            let initialCanvasSize = { width: 0, height: 0 };

            const DEFAULT_BLUR = 30;
            const DEFAULT_BG_SIZE = 180;
            const BLUR_PADDING = 250;

            // Dimensões da folha A4 em 300 DPI
            const A4_WIDTH_PX_LANDSCAPE = 3508;
            const A4_HEIGHT_PX_LANDSCAPE = 2480;
            
            // Dimensões de cada foto na grade
            const IMAGE_WIDTH_PX = 832.32;
            const IMAGE_HEIGHT_PX = 1177.2;

            // Espaçamentos calculados para o layout
            const HORIZONTAL_SPACING_PX = (A4_WIDTH_PX_LANDSCAPE - (4 * IMAGE_WIDTH_PX)) / 5;
            const VERTICAL_SPACING_PX = (A4_HEIGHT_PX_LANDSCAPE - (2 * IMAGE_HEIGHT_PX)) / 3;

            // Helper to get proportional image dimensions for drawing (object-fit: contain)
            const getProportionalContainDimensions = (imgWidth, imgHeight, boxWidth, boxHeight) => {
                const imageAspect = imgWidth / imgHeight;
                const boxAspect = boxWidth / boxHeight;
                let drawWidth, drawHeight, offsetX, offsetY;
                
                if (imageAspect > boxAspect) {
                    drawWidth = boxWidth;
                    drawHeight = boxWidth / imageAspect;
                    offsetX = 0;
                    offsetY = (boxHeight - drawHeight) / 2;
                } else {
                    drawHeight = boxHeight;
                    drawWidth = boxHeight * imageAspect;
                    offsetX = (boxWidth - drawWidth) / 2;
                    offsetY = 0;
                }
                return { drawWidth, drawHeight, offsetX, offsetY };
            };

            // Renders the image gallery with thumbnails and buttons
            const renderImages = () => {
                imageGallery.innerHTML = '';
                uploadedImages.forEach((image, index) => {
                    const card = document.createElement('div');
                    card.className = 'relative group w-full aspect-square rounded-xl overflow-hidden shadow-md border-2 border-gray-200 image-card';
                    card.innerHTML = `
                        <img src="${image.croppedUrl}" alt="Thumbnail" class="w-full h-full object-contain">
                        <div class="absolute inset-0 flex items-start justify-between p-2">
                            <!-- Ícone de Editar (canto superior esquerdo) -->
                            <button class="edit-btn bg-white/70 p-2 rounded-full shadow-md hover:bg-white transition-colors">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800" viewBox="0 0 20 20" fill="currentColor">
                                    <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zm-3.832 2.832l-3.35 3.35a2 2 0 00-.594 1.157l-.022.259a.5.5 0 00.174.457l1.242 1.242a.5.5 0 00.457.174l.259-.022c.433-.04.852-.164 1.242-.457l3.35-3.35-2.828-2.828z" />
                                </svg>
                            </button>
                            <!-- Ícone de Excluir (canto superior direito) -->
                            <button class="remove-btn bg-white/70 p-2 rounded-full shadow-md hover:bg-white transition-colors">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 10-2 0v6a1 1 0 102 0V8z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    `;
                    card.querySelector('.edit-btn').addEventListener('click', () => {
                        currentImageIndex = index;
                        openEditModal(image);
                    });
                    card.querySelector('.remove-btn').addEventListener('click', () => {
                        uploadedImages.splice(index, 1);
                        renderImages();
                        updateExportButtonState();
                    });
                    imageGallery.appendChild(card);
                });
                
                // Adicionar o cartão para adicionar novas fotos
                const addCard = document.createElement('div');
                addCard.className = 'w-full aspect-square rounded-xl border-2 border-dashed border-gray-300 flex items-center justify-center cursor-pointer hover:bg-gray-50 transition-colors';
                addCard.innerHTML = `
                    <span class="text-gray-400 text-6xl font-light">+</span>
                `;
                addCard.addEventListener('click', () => {
                    imageUpload.click();
                });
                imageGallery.appendChild(addCard);

                renderPreviewGallery('landscape');
            };

            // Update the state of the export button
            const updateExportButtonState = () => {
                const hasImages = uploadedImages.length > 0;
                exportLandscapeBtn.disabled = !hasImages;
                exportLandscapeJpgBtn.disabled = !hasImages;
                fullPreviewBtn.disabled = !hasImages;
                
                modalExportLandscapeBtn.disabled = !hasImages;
                modalExportLandscapeJpgBtn.disabled = !hasImages;

                renderPreviewGallery('landscape');

                // Oculta a seção de upload se houver imagens
                if (hasImages) {
                    uploadSection.classList.add('hidden');
                } else {
                    uploadSection.classList.remove('hidden');
                }
            };

            // Renders the A4 page preview gallery
            const renderPreviewGallery = (orientation) => {
                previewGallery.innerHTML = '';
                if (uploadedImages.length === 0) return;

                const gridCols = 4;
                const gridRows = 2;
                const IMAGES_PER_PAGE = gridCols * gridRows;
                const totalPages = Math.ceil(uploadedImages.length / IMAGES_PER_PAGE);

                for (let pageIndex = 0; pageIndex < totalPages; pageIndex++) {
                    const canvasWrapper = document.createElement('div');
                    canvasWrapper.className = 'preview-canvas-wrapper aspect-[1.414/1] relative';
                    const canvas = document.createElement('canvas');
                    const scale = 10;
                    const pageTotalWidth = A4_WIDTH_PX_LANDSCAPE;
                    const pageTotalHeight = A4_HEIGHT_PX_LANDSCAPE;
                    canvas.width = pageTotalWidth / scale;
                    canvas.height = pageTotalHeight / scale;

                    const zoomIndicator = document.createElement('div');
                    zoomIndicator.className = 'preview-zoom-indicator';
                    zoomIndicator.textContent = 'Zoom: 100%';
                    canvasWrapper.appendChild(canvas);
                    canvasWrapper.appendChild(zoomIndicator);
                    previewGallery.appendChild(canvasWrapper);

                    drawPageToCanvas(canvas, pageIndex, orientation);
                }
            };

            // Draws a single page to a given canvas
            const drawPageToCanvas = (canvas, pageIndex, orientation) => {
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const gridCols = 4;
                const gridRows = 2;
                const IMAGES_PER_PAGE = gridCols * gridRows;

                const pageTotalWidth = A4_WIDTH_PX_LANDSCAPE;
                const pageTotalHeight = A4_HEIGHT_PX_LANDSCAPE;
                const scaleFactor = canvas.width / pageTotalWidth;
                
                const startImageIndex = pageIndex * IMAGES_PER_PAGE;
                const endImageIndex = Math.min(startImageIndex + IMAGES_PER_PAGE, uploadedImages.length);
                const imagesToDraw = uploadedImages.slice(startImageIndex, endImageIndex);

                let imagePromiseChain = Promise.resolve();
                imagesToDraw.forEach((image, i) => {
                    imagePromiseChain = imagePromiseChain.then(() => {
                        const col = i % gridCols;
                        const row = Math.floor(i / gridCols);
                        
                        let xPos, yPos;
                        xPos = HORIZONTAL_SPACING_PX + col * (IMAGE_WIDTH_PX + HORIZONTAL_SPACING_PX);
                        yPos = VERTICAL_SPACING_PX + row * (IMAGE_HEIGHT_PX + VERTICAL_SPACING_PX);

                        // Cria um canvas temporário que funciona como a "máscara"
                        const compositeCanvas = document.createElement('canvas');
                        compositeCanvas.width = IMAGE_WIDTH_PX;
                        compositeCanvas.height = IMAGE_HEIGHT_PX;
                        const compositeCtx = compositeCanvas.getContext('2d');

                        return drawCompositeImage(compositeCtx, image)
                            .then(() => {
                                ctx.drawImage(compositeCanvas, xPos * scaleFactor, yPos * scaleFactor, IMAGE_WIDTH_PX * scaleFactor, IMAGE_HEIGHT_PX * scaleFactor);
                            });
                    });
                });
            };

            // Draws a single image, its background and captions on a canvas
            const drawCompositeImage = (ctx, imageObject) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.src = imageObject.croppedUrl;

                    const bgImg = new Image();
                    bgImg.src = imageObject.blurredUrl;
                    
                    let imagesLoaded = 0;
                    const totalImages = (imageObject.blurredUrl && imageObject.blurRadius > 0) ? 2 : 1;

                    const checkReady = () => {
                        imagesLoaded++;
                        if (imagesLoaded === totalImages) {
                            // Draw background if it exists
                            if (imageObject.blurredUrl && imageObject.blurRadius > 0) {
                                const { drawWidth, drawHeight, offsetX, offsetY } = getProportionalContainDimensions(bgImg.width, bgImg.height, IMAGE_WIDTH_PX, IMAGE_HEIGHT_PX);
                                const bgScale = imageObject.backgroundSize / 100;
                                const finalBgWidth = drawWidth * bgScale;
                                const finalBgHeight = drawHeight * bgScale;
                                const finalBgOffsetX = offsetX + (drawWidth - finalBgWidth) / 2;
                                const finalBgOffsetY = offsetY + (drawHeight - finalBgHeight) / 2;
                                ctx.drawImage(bgImg, finalBgOffsetX, finalBgOffsetY, finalBgWidth, finalBgHeight);
                            }

                            // Draw foreground image with zoom applied
                            const { drawWidth, drawHeight, offsetX, offsetY } = getProportionalContainDimensions(img.width, img.height, IMAGE_WIDTH_PX, IMAGE_HEIGHT_PX);
                            
                            // Apply zoom if exists
                            let zoomFactor = 1;
                            if (imageObject.zoom && imageObject.zoom !== 100) {
                                zoomFactor = imageObject.zoom / 100;
                            }

                            const zoomedWidth = drawWidth * zoomFactor;
                            const zoomedHeight = drawHeight * zoomFactor;
                            const zoomOffsetX = offsetX - (zoomedWidth - drawWidth) / 2;
                            const zoomOffsetY = offsetY - (zoomedHeight - drawHeight) / 2;

                            ctx.drawImage(img, zoomOffsetX, zoomOffsetY, zoomedWidth, zoomedHeight);

                            // Draw captions
                            drawCaptionsOnCanvas(ctx, imageObject.captions, 0, 0, 1);
                            resolve();
                        }
                    };

                    img.onload = checkReady;
                    img.onerror = resolve;
                    if (totalImages === 2) {
                        bgImg.onload = checkReady;
                        bgImg.onerror = resolve;
                    } else {
                        checkReady();
                    }
                });
            };

            // Function to open the main edit modal
            const openEditModal = (image) => {
                editModal.classList.remove('hidden');

                // Load existing data
                const existingCaptions = image.captions || [];
                image.tempCaptions = JSON.parse(JSON.stringify(existingCaptions));
                image.tempBlurRadius = image.blurRadius;
                image.tempBackgroundSize = image.backgroundSize;
                image.tempZoom = image.zoom || 100;

                blurSlider.value = image.tempBlurRadius;
                blurValueText.textContent = `${image.tempBlurRadius} px`;
                backgroundSizeSlider.value = image.tempBackgroundSize;
                backgroundSizeValueText.textContent = `${image.tempBackgroundSize} %`;
                zoomSlider.value = image.tempZoom;
                zoomValue.textContent = `${image.tempZoom}%`;

                initialCanvasSize = { width: image.imgElement.width, height: image.imgElement.height };

                // Resize and draw canvas based on container
                resizeCanvasAndDraw();

                // Create mask lines
                createMaskLines();

                // Listen for window resize to make the canvas responsive
                window.addEventListener('resize', resizeCanvasAndDraw);
            };

            // Create mask lines for the editor
            const createMaskLines = () => {
                maskOverlay.innerHTML = '';
                
                // Create vertical lines
                for (let i = 1; i < 4; i++) {
                    const line = document.createElement('div');
                    line.className = 'mask-line vertical';
                    line.style.left = `${(i * 25)}%`;
                    maskOverlay.appendChild(line);
                }
                
                // Create horizontal lines
                for (let i = 1; i < 2; i++) {
                    const line = document.createElement('div');
                    line.className = 'mask-line horizontal';
                    line.style.top = `${(i * 50)}%`;
                    maskOverlay.appendChild(line);
                }
            };

            // Resizes the canvas to fit its container while maintaining aspect ratio
            const resizeCanvasAndDraw = () => {
                const containerRect = editorArea.getBoundingClientRect();
                const containerWidth = containerRect.width;
                const containerHeight = containerRect.height;
                const image = uploadedImages[currentImageIndex].imgElement;

                let canvasWidth, canvasHeight;
                const imageAspect = image.width / image.height;
                const containerAspect = containerWidth / containerHeight;

                if (containerAspect > imageAspect) {
                    canvasHeight = containerHeight;
                    canvasWidth = canvasHeight * imageAspect;
                } else {
                    canvasWidth = containerWidth;
                    canvasHeight = canvasWidth / imageAspect;
                }

                editorCanvas.width = canvasWidth;
                editorCanvas.height = canvasHeight;

                // Redraw canvas with temp data
                redrawEditorCanvas();
            };

            // Redraws the editing canvas based on current state
            const redrawEditorCanvas = () => {
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                const image = uploadedImages[currentImageIndex];

                // Draw background if needed
                if (currentTool === 'background' && image.blurredUrl) {
                    const blurredImg = new Image();
                    blurredImg.src = image.blurredUrl;
                    blurredImg.onload = () => {
                        const { drawWidth, drawHeight, offsetX, offsetY } = getProportionalContainDimensions(blurredImg.width, blurredImg.height, editorCanvas.width, editorCanvas.height);
                        const bgScale = image.tempBackgroundSize / 100;
                        const bgWidth = drawWidth * bgScale;
                        const bgHeight = drawHeight * bgScale;
                        const bgOffsetX = offsetX + (drawWidth - bgWidth) / 2;
                        const bgOffsetY = offsetY + (drawHeight - bgHeight) / 2;

                        editorCtx.drawImage(blurredImg, bgOffsetX, bgOffsetY, bgWidth, bgHeight);
                    };
                } else {
                    // Draw foreground image with zoom applied
                    const { drawWidth, drawHeight, offsetX, offsetY } = getProportionalContainDimensions(image.imgElement.width, image.imgElement.height, editorCanvas.width, editorCanvas.height);
                    
                    // Apply zoom if exists
                    let zoomFactor = 1;
                    if (image.tempZoom && image.tempZoom !== 100) {
                        zoomFactor = image.tempZoom / 100;
                    }

                    const zoomedWidth = drawWidth * zoomFactor;
                    const zoomedHeight = drawHeight * zoomFactor;
                    const zoomOffsetX = offsetX - (zoomedWidth - drawWidth) / 2;
                    const zoomOffsetY = offsetY - (zoomedHeight - drawHeight) / 2;

                    editorCtx.drawImage(image.imgElement, zoomOffsetX, zoomOffsetY, zoomedWidth, zoomedHeight);
                    
                    // Draw captions
                    drawCaptionsOnCanvas(editorCtx, image.tempCaptions, offsetX, offsetY, drawWidth / image.imgElement.width);
                }
            };

            // Draws captions on a given canvas
            const drawCaptionsOnCanvas = (ctx, captions, xOffset = 0, yOffset = 0, scale = 1) => {
                captions.forEach(caption => {
                    ctx.font = `${caption.size * scale}px "${caption.font}"`;
                    ctx.fillStyle = caption.color;
                    ctx.strokeStyle = caption.outlineColor;
                    ctx.lineWidth = caption.strokeWidth * scale;
                    ctx.lineJoin = 'round';
                    ctx.strokeText(caption.text, xOffset + caption.x * scale, yOffset + caption.y * scale);
                    ctx.fillText(caption.text, xOffset + caption.x * scale, yOffset + caption.y * scale);
                });
            };

            // Handles tool selection
            const setTool = (toolName) => {
                currentTool = toolName;
                zoomControls.classList.add('hidden');
                captionControls.classList.add('hidden');
                backgroundControls.classList.add('hidden');

                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.remove('bg-blue-500', 'text-white');
                    btn.classList.add('bg-gray-200', 'text-gray-700');
                });

                const image = uploadedImages[currentImageIndex];

                if (toolName === 'zoom') {
                    zoomControls.classList.remove('hidden');
                    toolZoomBtn.classList.remove('bg-gray-200', 'text-gray-700');
                    toolZoomBtn.classList.add('bg-blue-500', 'text-white');
                    
                    // Initialize zoom if not exists
                    if (image.tempZoom === undefined) {
                        image.tempZoom = 100;
                    }
                    zoomSlider.value = image.tempZoom;
                    zoomValue.textContent = `${image.tempZoom}%`;
                    
                    redrawEditorCanvas();
                } else if (toolName === 'caption') {
                    captionControls.classList.remove('hidden');
                    toolCaptionBtn.classList.remove('bg-gray-200', 'text-gray-700');
                    toolCaptionBtn.classList.add('bg-blue-500', 'text-white');

                    if (image.tempCaptions.length === 0) {
                        image.tempCaptions.push({
                            text: 'Sua Legenda',
                            x: 50,
                            y: initialCanvasSize.height - 50,
                            color: '#000000',
                            outlineColor: '#FFFFFF',
                            size: 20,
                            strokeWidth: 0,
                            font: 'Valentine Baby, sans-serif'
                        });
                    }
                    captionTextInput.value = image.tempCaptions[0].text;
                    captionColorInput.value = image.tempCaptions[0].color;
                    captionOutlineColorInput.value = image.tempCaptions[0].outlineColor;
                    captionSizeSlider.value = image.tempCaptions[0].size;
                    captionSizeValueText.textContent = `${image.tempCaptions[0].size} px`;
                    captionStrokeSlider.value = image.tempCaptions[0].strokeWidth;
                    captionStrokeValueText.textContent = `${image.tempCaptions[0].strokeWidth} px`;
                    captionFontSelect.value = image.tempCaptions[0].font;
                    
                    addCaptionRealtimePreview();
                    
                    redrawEditorCanvas();
                } else if (toolName === 'background') {
                    backgroundControls.classList.remove('hidden');
                    toolBackgroundBtn.classList.remove('bg-gray-200', 'text-gray-700');
                    toolBackgroundBtn.classList.add('bg-blue-500', 'text-white');
                    
                    addBackgroundRealtimePreview();
                    
                    redrawEditorCanvas();
                }
            };

            // Adiciona preview em tempo real para controles de legenda
            const addCaptionRealtimePreview = () => {
                const realtimeElements = document.querySelectorAll('#caption-controls .realtime-preview');
                realtimeElements.forEach(element => {
                    element.addEventListener('input', () => {
                        if (uploadedImages[currentImageIndex].tempCaptions.length > 0) {
                            const caption = uploadedImages[currentImageIndex].tempCaptions[0];
                            caption.text = captionTextInput.value;
                            caption.color = captionColorInput.value;
                            caption.outlineColor = captionOutlineColorInput.value;
                            caption.size = parseInt(captionSizeSlider.value);
                            caption.strokeWidth = parseInt(captionStrokeSlider.value);
                            caption.font = captionFontSelect.value;
                            
                            captionSizeValueText.textContent = `${caption.size} px`;
                            captionStrokeValueText.textContent = `${caption.strokeWidth} px`;
                            
                            redrawEditorCanvas();
                        }
                    });
                });
            };

            // Adiciona preview em tempo real para controles de fundo
            const addBackgroundRealtimePreview = () => {
                const realtimeElements = document.querySelectorAll('#background-controls .realtime-preview');
                realtimeElements.forEach(element => {
                    element.addEventListener('input', () => {
                        const image = uploadedImages[currentImageIndex];
                        image.tempBlurRadius = parseInt(blurSlider.value);
                        image.tempBackgroundSize = parseInt(backgroundSizeSlider.value);
                        
                        blurValueText.textContent = `${image.tempBlurRadius} px`;
                        backgroundSizeValueText.textContent = `${image.tempBackgroundSize} %`;
                        
                        if (image.tempBlurRadius > 0) {
                            applyBlur(image.imgElement, image, image.tempBlurRadius);
                        }
                        redrawEditorCanvas();
                    });
                });
            };

            // Event listeners for tool buttons
            toolZoomBtn.addEventListener('click', () => setTool('zoom'));
            toolCaptionBtn.addEventListener('click', () => setTool('caption'));
            toolBackgroundBtn.addEventListener('click', () => setTool('background'));

            // Event listeners for zoom controls
            zoomSlider.addEventListener('input', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempZoom = parseInt(zoomSlider.value);
                zoomValue.textContent = `${image.tempZoom}%`;
                redrawEditorCanvas();
            });

            zoomInBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempZoom = Math.min(parseInt(image.tempZoom) + 10, 300);
                zoomSlider.value = image.tempZoom;
                zoomValue.textContent = `${image.tempZoom}%`;
                redrawEditorCanvas();
            });

            zoomOutBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempZoom = Math.max(parseInt(image.tempZoom) - 10, 50);
                zoomSlider.value = image.tempZoom;
                zoomValue.textContent = `${image.tempZoom}%`;
                redrawEditorCanvas();
            });

            zoomResetBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempZoom = 100;
                zoomSlider.value = image.tempZoom;
                zoomValue.textContent = `${image.tempZoom}%`;
                redrawEditorCanvas();
            });

            saveZoomBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.zoom = image.tempZoom;
                setTool(null);
                renderImages();
            });

            discardZoomBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempZoom = image.zoom || 100;
                redrawEditorCanvas();
                setTool(null);
            });

            // Applies the blur effect and updates the image data
            const applyBlur = (imageElement, imageObject, blurRadius) => {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = imageElement.width + BLUR_PADDING;
                tempCanvas.height = imageElement.height + BLUR_PADDING;
                const ctx = tempCanvas.getContext('2d');
                ctx.filter = `blur(${blurRadius}px)`;
                ctx.drawImage(imageElement, BLUR_PADDING / 2, BLUR_PADDING / 2, imageElement.width, imageElement.height);
                imageObject.blurredUrl = tempCanvas.toDataURL('image/png');
            };

            // Save and Discard actions for each tool
            saveCaptionBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.captions = JSON.parse(JSON.stringify(image.tempCaptions));
                setTool(null);
                renderImages();
            });

            discardCaptionBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempCaptions = JSON.parse(JSON.stringify(image.captions));
                setTool(null);
                redrawEditorCanvas();
            });

            saveBackgroundBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.blurRadius = image.tempBlurRadius;
                image.backgroundSize = image.tempBackgroundSize;
                applyBlur(image.imgElement, image, image.blurRadius);
                setTool(null);
                renderImages();
            });

            discardBackgroundBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempBlurRadius = image.blurRadius;
                image.tempBackgroundSize = image.backgroundSize;
                applyBlur(image.imgElement, image, image.tempBlurRadius);
                setTool(null);
                redrawEditorCanvas();
            });

            // Back button simply closes the modal without saving
            backBtn.addEventListener('click', () => {
                editModal.classList.add('hidden');
                window.removeEventListener('resize', resizeCanvasAndDraw);
                renderImages();
            });

            // Event listener for image upload
            imageUpload.addEventListener('change', (event) => {
                const files = event.target.files;
                if (files.length > 0) {
                    loadingOverlay.classList.remove('hidden');
                    loadingText.textContent = 'Carregando imagens...';
                    
                    let loadedCount = 0;
                    const totalFiles = files.length;
                    
                    Array.from(files).forEach(file => {
                        if (!file.type.match('image.*')) {
                            loadedCount++;
                            if (loadedCount === totalFiles) {
                                loadingOverlay.classList.add('hidden');
                            }
                            statusMessage.textContent = 'Por favor, selecione apenas arquivos de imagem.';
                            return;
                        }
                        
                        if (file.size > 10 * 1024 * 1024) {
                            loadedCount++;
                            if (loadedCount === totalFiles) {
                                loadingOverlay.classList.add('hidden');
                            }
                            statusMessage.textContent = 'Imagem muito grande. Por favor, selecione imagens menores que 10MB.';
                            return;
                        }
                        
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                let isRotated = false;
                                let processedImg = img;
                                let imgWidth = img.width;
                                let imgHeight = img.height;

                                if (imgWidth - imgHeight >= 250) {
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    
                                    canvas.width = imgHeight;
                                    canvas.height = imgWidth;
                                    
                                    ctx.translate(canvas.width / 2, canvas.height / 2);
                                    ctx.rotate(90 * Math.PI / 180);
                                    ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);

                                    processedImg = new Image();
                                    processedImg.src = canvas.toDataURL('image/png');
                                    
                                    isRotated = true;
                                    imgWidth = processedImg.width;
                                    imgHeight = processedImg.height;
                                }

                                const newImage = {
                                    id: Date.now() + Math.random(),
                                    originalUrl: e.target.result,
                                    imgElement: processedImg,
                                    croppedUrl: processedImg.src,
                                    crop: { x: 0, y: 0, width: imgWidth, height: imgHeight },
                                    blurredUrl: null,
                                    blurRadius: DEFAULT_BLUR,
                                    backgroundSize: DEFAULT_BG_SIZE,
                                    zoom: 100,
                                    captions: [],
                                    isRotated: isRotated,
                                    tempCaptions: [],
                                    tempBlurRadius: DEFAULT_BLUR,
                                    tempBackgroundSize: DEFAULT_BG_SIZE,
                                    tempZoom: 100,
                                };
                                applyBlur(processedImg, newImage, DEFAULT_BLUR);
                                
                                if (newImage.isRotated) {
                                    uploadedImages.unshift(newImage);
                                } else {
                                    uploadedImages.push(newImage);
                                }

                                loadedCount++;
                                if (loadedCount === totalFiles) {
                                    loadingOverlay.classList.add('hidden');
                                    renderImages();
                                    updateExportButtonState();
                                    statusMessage.textContent = `${totalFiles} imagem(ns) carregada(s) com sucesso!`;
                                }
                            };
                            img.src = e.target.result;
                        };
                        reader.readAsDataURL(file);
                    });
                }
            });

            // Event listener for the "Clear All" button
            clearAllBtn.addEventListener('click', () => {
                if (uploadedImages.length === 0) return;
                
                if (confirm('Tem certeza que deseja remover todas as imagens?')) {
                    uploadedImages = [];
                    imageGallery.innerHTML = '';
                    previewGallery.innerHTML = '';
                    updateExportButtonState();
                    statusMessage.textContent = 'Todas as imagens foram removidas.';
                }
            });

            // Lógica para o novo botão de pré-visualização completa
            fullPreviewBtn.addEventListener('click', () => {
                if (uploadedImages.length === 0) return;

                fullPreviewModal.classList.remove('hidden');
                fullPreviewArea.innerHTML = '';
                currentPageIndex = 0;

                const orientation = 'landscape';
                const pageTotalWidth = A4_WIDTH_PX_LANDSCAPE;
                const pageTotalHeight = A4_HEIGHT_PX_LANDSCAPE;
                const IMAGES_PER_PAGE = 8;
                const totalPages = Math.ceil(uploadedImages.length / IMAGES_PER_PAGE);

                if (totalPages > 1) {
                    fullPreviewNav.classList.remove('hidden');
                    prevPageBtn.disabled = currentPageIndex === 0;
                    nextPageBtn.disabled = currentPageIndex === totalPages - 1;
                } else {
                    fullPreviewNav.classList.add('hidden');
                }
                
                pageIndicator.textContent = `Página ${currentPageIndex + 1} de ${totalPages}`;

                loadingOverlay.classList.remove('hidden');
                loadingText.textContent = 'Gerando pré-visualização...';

                let renderPromiseChain = Promise.resolve();
                for (let i = 0; i < totalPages; i++) {
                    renderPromiseChain = renderPromiseChain.then(() => {
                        const previewCanvas = document.createElement('canvas');
                        previewCanvas.width = pageTotalWidth;
                        previewCanvas.height = pageTotalHeight;
                        const previewCtx = previewCanvas.getContext('2d');
                        previewCtx.fillStyle = '#FFFFFF';
                        previewCtx.fillRect(0, 0, pageTotalWidth, pageTotalHeight);

                        return new Promise((resolvePage) => {
                            let drawPromiseChain = Promise.resolve();
                            const startImageIndex = i * IMAGES_PER_PAGE;
                            const endImageIndex = Math.min(startImageIndex + IMAGES_PER_PAGE, uploadedImages.length);

                            for (let j = startImageIndex; j < endImageIndex; j++) {
                                drawPromiseChain = drawPromiseChain.then(() => {
                                    const imageInPageIndex = j % IMAGES_PER_PAGE;
                                    const col = imageInPageIndex % 4;
                                    const row = Math.floor(imageInPageIndex / 4);

                                    const xPos = HORIZONTAL_SPACING_PX + col * (IMAGE_WIDTH_PX + HORIZONTAL_SPACING_PX);
                                    const yPos = VERTICAL_SPACING_PX + row * (IMAGE_HEIGHT_PX + VERTICAL_SPACING_PX);

                                    const compositeCanvas = document.createElement('canvas');
                                    compositeCanvas.width = IMAGE_WIDTH_PX;
                                    compositeCanvas.height = IMAGE_HEIGHT_PX;
                                    const compositeCtx = compositeCanvas.getContext('2d');

                                    return drawCompositeImage(compositeCtx, uploadedImages[j]).then(() => {
                                        previewCtx.drawImage(compositeCanvas, xPos, yPos);
                                    });
                                });
                            }
                            drawPromiseChain.then(() => {
                                const previewImage = new Image();
                                previewImage.src = previewCanvas.toDataURL('image/png');
                                previewImage.className = 'preview-page';
                                fullPreviewArea.appendChild(previewImage);
                                resolvePage();
                            });
                        });
                    });
                }
                
                renderPromiseChain.then(() => {
                    loadingOverlay.classList.add('hidden');
                });
            });

            closePreviewBtn.addEventListener('click', () => {
                fullPreviewModal.classList.add('hidden');
            });
            
            // Navegação entre pranchetas
            prevPageBtn.addEventListener('click', () => {
                const totalPages = Math.ceil(uploadedImages.length / 8);
                if (currentPageIndex > 0) {
                    currentPageIndex--;
                    pageIndicator.textContent = `Página ${currentPageIndex + 1} de ${totalPages}`;
                    nextPageBtn.disabled = false;
                    if (currentPageIndex === 0) {
                        prevPageBtn.disabled = true;
                    }
                }
            });

            nextPageBtn.addEventListener('click', () => {
                const totalPages = Math.ceil(uploadedImages.length / 8);
                if (currentPageIndex < totalPages - 1) {
                    currentPageIndex++;
                    pageIndicator.textContent = `Página ${currentPageIndex + 1} de ${totalPages}`;
                    prevPageBtn.disabled = false;
                    if (currentPageIndex === totalPages - 1) {
                        nextPageBtn.disabled = true;
                    }
                }
            });

            // Common export function
            const exportDocument = (orientation, format) => {
                let gridCols = 4;
                let gridRows = 2;
                let pageTotalWidth = A4_WIDTH_PX_LANDSCAPE;
                let pageTotalHeight = A4_HEIGHT_PX_LANDSCAPE;
                
                const IMAGES_PER_PAGE = gridCols * gridRows;
                const totalPages = Math.ceil(uploadedImages.length / IMAGES_PER_PAGE);

                loadingOverlay.classList.remove('hidden');
                loadingText.textContent = `Gerando ${format.toUpperCase()}... Por favor, aguarde.`;
                
                statusMessage.textContent = `Gerando ${format.toUpperCase()}... Por favor, aguarde.`;
                exportLandscapeBtn.disabled = true;
                exportLandscapeJpgBtn.disabled = true;

                const doc = (format === 'pdf') ? new jsPDF({
                    orientation: orientation,
                    unit: 'px',
                    format: [pageTotalWidth, pageTotalHeight]
                }) : null;
                
                let processedImages = 0;

                function processPage(pageIndex) {
                    if (pageIndex >= totalPages) {
                         if (format === 'pdf') {
                            doc.save(`documento_imagens_${orientation}.pdf`);
                        }
                        statusMessage.textContent = `${format.toUpperCase()} gerado com sucesso!`;
                        exportLandscapeBtn.disabled = false;
                        exportLandscapeJpgBtn.disabled = false;
                        loadingOverlay.classList.add('hidden');
                        return;
                    }

                    const pageCanvas = document.createElement('canvas');
                    pageCanvas.width = pageTotalWidth;
                    pageCanvas.height = pageTotalHeight;
                    const pageCtx = pageCanvas.getContext('2d');
                    pageCtx.fillStyle = '#FFFFFF';
                    pageCtx.fillRect(0, 0, pageTotalWidth, pageTotalHeight);

                    const startImageIndex = pageIndex * IMAGES_PER_PAGE;
                    const endImageIndex = Math.min(startImageIndex + IMAGES_PER_PAGE, uploadedImages.length);

                    let drawPromiseChain = Promise.resolve();
                    for (let i = startImageIndex; i < endImageIndex; i++) {
                        drawPromiseChain = drawPromiseChain.then(() => {
                            const imageInPageIndex = i % IMAGES_PER_PAGE;
                            const col = imageInPageIndex % gridCols;
                            const row = Math.floor(imageInPageIndex / gridCols);
                            
                            let xPos = HORIZONTAL_SPACING_PX + col * (IMAGE_WIDTH_PX + HORIZONTAL_SPACING_PX);
                            let yPos = VERTICAL_SPACING_PX + row * (IMAGE_HEIGHT_PX + VERTICAL_SPACING_PX);

                            const compositeCanvas = document.createElement('canvas');
                            compositeCanvas.width = IMAGE_WIDTH_PX;
                            compositeCanvas.height = IMAGE_HEIGHT_PX;
                            const compositeCtx = compositeCanvas.getContext('2d');

                            return drawCompositeImage(compositeCtx, uploadedImages[i])
                                .then(() => {
                                    pageCtx.drawImage(compositeCanvas, xPos, yPos);
                                });
                        });
                    }

                    drawPromiseChain.then(() => {
                        const dataUrl = pageCanvas.toDataURL(`image/${format === 'jpg' ? 'jpeg' : 'png'}`, 1.0);
                        if (format === 'pdf') {
                            if (pageIndex > 0) doc.addPage();
                            doc.addImage(dataUrl, 'PNG', 0, 0, pageTotalWidth, pageTotalHeight);
                        } else {
                            const link = document.createElement('a');
                            link.href = dataUrl;
                            link.download = `documento_imagens_${orientation}_pagina_${pageIndex + 1}.jpg`;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                        }
                        processPage(pageIndex + 1);
                    }).catch(err => {
                        console.error('Failed to process image:', err);
                        statusMessage.textContent = `Erro ao carregar uma imagem para exportação.`;
                        exportLandscapeBtn.disabled = false;
                        exportLandscapeJpgBtn.disabled = false;
                        loadingOverlay.classList.add('hidden');
                    });
                }
                processPage(0);
            };

            // Event listeners for the export buttons
            exportLandscapeBtn.addEventListener('click', () => exportDocument('landscape', 'pdf'));
            exportLandscapeJpgBtn.addEventListener('click', () => exportDocument('landscape', 'jpg'));

            // Event listeners for the new modal export buttons
            modalExportLandscapeBtn.addEventListener('click', () => {
                exportDocument('landscape', 'pdf');
                fullPreviewModal.classList.add('hidden');
            });
            modalExportLandscapeJpgBtn.addEventListener('click', () => {
                exportDocument('landscape', 'jpg');
                fullPreviewModal.classList.add('hidden');
            });

            // Implementação do Drag & Drop
            const uploadSectionElement = document.getElementById('upload-section');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadSectionElement.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadSectionElement.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                uploadSectionElement.addEventListener(eventName, unhighlight, false);
            });
            
            function highlight() {
                uploadSectionElement.classList.add('drag-over');
            }
            
            function unhighlight() {
                uploadSectionElement.classList.remove('drag-over');
            }
            
            uploadSectionElement.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    imageUpload.files = files;
                    const event = new Event('change');
                    imageUpload.dispatchEvent(event);
                }
            }

            // Inicialização da aplicação
            updateExportButtonState();
        };
    </script>
</body>
</html>
