<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SuecoEdit - Polaroides</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="favicon.png">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- jsPDF CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Font Awesome para ícones -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Estilos anteriores mantidos */
        @import url('https://fonts.googleapis.com/css2?family=Caveat+Brush&family=Cinzel:wght@400..900&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Pacifico&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Shadows+Into+Light&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Indie+Flower&display=swap');
        
        @font-face {
            font-family: 'Valentine Baby';
            src: url('https://fonts.cdnfonts.com/s/72225/Valentine Baby.woff') format('woff');
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 14px 0 rgba(0, 0, 0, 0.2);
            background-color: #f3f4f6;
        }

        .hero-section {
            background: linear-gradient(135deg, #60a5fa, #3b82f6);
            color: white;
            padding: 2rem 1rem;
            text-align: center;
            border-bottom-left-radius: 2rem;
            border-bottom-right-radius: 2rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 14px 0 rgba(0, 0, 0, 0.2);
        }

        .hero-section h1 {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
        }

        .hero-section p {
            font-size: 1rem;
            opacity: 0.9;
        }

        .container-wrapper {
            max-width: 100%;
            padding: 0.5rem;
        }
        
        /* Estilos do Editor de Imagens */
        .container {
            max-width: 960px;
        }
        .file-input-label {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .file-input-label:hover {
            background-color: #2563eb;
        }
        .editor-container {
            position: relative;
            user-select: none;
            overflow: hidden;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #3b82f6; /* Fundo azul para diferenciar */
        }
        
        /* Novos estilos para a visualização com máscara e linhas */
        .mask-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .mask-line {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.6);
            z-index: 11;
        }
        
        .mask-line.vertical {
            width: 1px;
            height: 100%;
        }
        
        .mask-line.horizontal {
            width: 100%;
            height: 1px;
        }
        
        .preview-canvas-wrapper {
            position: relative;
            user-select: none;
            overflow: hidden;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #3b82f6; /* Fundo azul para diferenciar */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            margin: 0.5rem;
        }
        .preview-zoom-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 12px;
        }

        /* Carousel Styles */
        .carousel-container {
            position: relative;
            overflow: hidden;
            max-width: 700px;
            margin: 0 auto 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 4px 14px 0 rgba(0, 0, 0, 0.1);
            height: 120px;
        }
        .carousel-slide-wrapper {
            display: flex;
            transition: transform 0.5s ease;
            height: 100%;
        }
        .carousel-slide {
            min-width: 100%;
            flex-shrink: 0;
            padding: 1rem;
            text-align: center;
            background-color: #ffffff;
            border-radius: 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .carousel-dot {
            height: 10px;
            width: 10px;
            background-color: #bbb;
            border-radius: 50%;
            display: inline-block;
            transition: background-color 0.6s ease;
            margin: 0 3px;
            cursor: pointer;
        }
        .active-dot {
            background-color: #3b82f6;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .spinner {
            animation: spin 1s linear infinite;
        }

        /* Full Preview Area - MODIFICADO para grade 2x4 */
        #full-preview-area {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 1rem;
            overflow-y: auto;
            align-items: start;
            justify-items: center;
            max-height: 70vh;
            background-color: #3b82f6; /* Fundo azul para diferenciar */
        }
        
        #full-preview-area .preview-page {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        /* Novos estilos para melhorias */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            flex-direction: column;
        }
        
        .image-card {
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .image-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        
        .tooltip {
            position: relative;
        }
        
        .tooltip .tooltip-text {
            visibility: hidden;
            width: 120px;
            background-color: black;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -60px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* Preview em tempo real para controles */
        .realtime-preview {
            transition: all 0.3s ease;
        }
        
        /* Estilos para mobile */
        @media (max-width: 768px) {
            .hero-section {
                padding: 1.5rem 1rem;
            }
            
            .hero-section h1 {
                font-size: 1.5rem;
            }
            
            .container {
                padding: 1rem;
            }
            
            .flex-row-mobile {
                flex-direction: column;
            }
            
            .button-mobile {
                width: 100%;
                margin-bottom: 0.5rem;
            }
            
            /* Ajustes para o modal em mobile */
            #edit-modal > div {
                width: 95%;
                height: 90%;
                padding: 1rem;
            }
            
            .tool-btn {
                font-size: 0.8rem;
                padding: 0.5rem;
            }
            
            /* Ajustes para a pré-visualização em mobile */
            #full-preview-area {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(4, 1fr);
            }
        }
        
        /* Melhorias de acessibilidade */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        /* Melhorias para os controles de legenda */
        .caption-preview {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Manter proporção da imagem */
        .maintain-aspect-ratio {
            object-fit: contain;
        }
        
        /* Estilos para a área de upload com drag and drop */
        .drag-over {
            background-color: #dbeafe !important;
            border-color: #3b82f6 !important;
        }
        
        /* Estilos para os controles de zoom */
        .zoom-controls {
            transition: all 0.3s ease;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        /* Novos estilos para o editor de legendas */
        .caption-editable {
            position: absolute;
            cursor: move;
            user-select: none;
            z-index: 20;
            padding: 5px;
            border: 1px dashed transparent;
        }
        
        .caption-editable:hover {
            border-color: #3b82f6;
        }
        
        .caption-editable.selected {
            border-color: #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
        }
        
        .caption-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .caption-control-group {
            display: flex;
            flex-direction: column;
            min-width: 120px;
        }
        
        .color-preview {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 15;
        }
        
        .drawing-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        
        .grid-option {
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .grid-option:hover {
            border-color: #3b82f6;
            background-color: #f0f7ff;
        }
        
        .grid-option.selected {
            border-color: #3b82f6;
            background-color: #dbeafe;
        }
        
        .grid-preview {
            width: 100%;
            height: 100px;
            display: grid;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .grid-preview-cell {
            background-color: #3b82f6;
            border-radius: 3px;
        }
        
        /* Estilos para as opções de grade */
        .grid-options-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        /* Novos estilos para os controles de edição avançada */
        .advanced-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .advanced-control-group {
            display: flex;
            flex-direction: column;
        }
        
        .advanced-control-group label {
            font-size: 0.8rem;
            margin-bottom: 5px;
        }
        
        .advanced-control-group input {
            width: 100%;
        }
        
        .color-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .color-button {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 1px solid #ccc;
            cursor: pointer;
        }
        
        /* Estilo para botão de próxima imagem */
        .next-image-btn {
            background-color: #10b981;
            color: white;
        }
        
        .next-image-btn:hover {
            background-color: #059669;
        }
        
        /* Estilo para botão de reset */
        .reset-btn {
            background-color: #ef4444;
            color: white;
        }
        
        .reset-btn:hover {
            background-color: #dc2626;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="flex items-center gap-3 p-4 bg-white shadow-md">
        <img src="favicon.png" alt="Logo" class="w-8 h-8">
        <h1 class="text-xl font-bold text-gray-700">SuecoEdit</h1>
    </div>
    
    <!-- Início do código da aplicação SuecoEdit -->
    <div class="container mx-auto px-4 py-6">
        <!-- Título -->
        <div class="text-center mb-8">
            <h2 class="text-3xl font-bold text-blue-800">Criar Fotos Polaroides</h2>
            <p class="text-gray-600 mt-2">Arraste e solte fotos para criar fotos polaroides com diferentes formatos de grade.</p>
        </div>

        <!-- Seção de Upload com Drag & Drop -->
        <div id="upload-section" class="mt-6 mb-6 p-8 border-2 border-dashed border-gray-300 rounded-xl text-center bg-white transition-colors duration-300">
            <div class="flex flex-col items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
                <p class="text-lg font-medium text-gray-700 mb-2">Arraste e solte suas imagens aqui</p>
                <p class="text-sm text-gray-500 mb-4">ou</p>
                <label for="image-upload" class="file-input-label bg-blue-500 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-blue-600 transition-colors inline-block cursor-pointer">
                    <span>Selecionar Imagens</span>
                    <input type="file" id="image-upload" accept="image/*" multiple class="hidden">
                </label>
                <p class="text-xs text-gray-400 mt-4">Suporte a JPEG e PNG. Máx. 10MB por imagem.</p>
            </div>
        </div>

        <!-- Controles do layout de imagens -->
        <div class="flex flex-col sm:flex-row justify-between items-center mb-6 gap-4">
            <h2 class="text-xl font-bold text-gray-800">Imagens Carregadas</h2>
            <button id="clear-all-btn" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-red-600 transition-colors transform hover:scale-105 w-full sm:w-auto">
                Limpar Tudo
            </button>
        </div>

        <!-- Galeria de miniaturas de imagens -->
        <div id="image-gallery" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 mb-8">
            <!-- As miniaturas serão adicionadas aqui via JavaScript -->
        </div>

        <!-- Controles e Opções -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <div class="p-6 bg-white rounded-xl shadow-md">
                <h2 class="text-lg font-bold mb-4 text-blue-800">Opções de Layout</h2>
                <div class="flex flex-col space-y-3">
                    <label class="block">
                        <span class="text-gray-700">Tipo de Grade:</span>
                        <select id="grid-type-select" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                            <option value="2x4">2x4 (8 fotos por página)</option>
                            <option value="2x2">2x2 (4 fotos por página)</option>
                            <option value="1x2">1x2 (2 fotos por página)</option>
                            <option value="3x3">3x3 (9 fotos por página)</option>
                        </select>
                    </label>
                    
                    <div class="grid-options-container">
                        <div class="grid-option selected" data-grid="2x4">
                            <div class="grid-preview" style="grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(2, 1fr);">
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                            </div>
                            <span>2x4</span>
                        </div>
                        
                        <div class="grid-option" data-grid="2x2">
                            <div class="grid-preview" style="grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr);">
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                            </div>
                            <span>2x2</span>
                        </div>
                        
                        <div class="grid-option" data-grid="1x2">
                            <div class="grid-preview" style="grid-template-columns: repeat(2, 1fr); grid-template-rows: 1fr;">
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                            </div>
                            <span>1x2</span>
                        </div>

                        <div class="grid-option" data-grid="3x3">
                            <div class="grid-preview" style="grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);">
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                                <div class="grid-preview-cell"></div>
                            </div>
                            <span>3x3</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Visualização da Folha A4 em Mosaico -->
            <div class="p-6 bg-white rounded-xl shadow-md">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-bold text-blue-800">Pré-visualização</h2>
                </div>
                <div id="preview-gallery" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <!-- O mosaico de pré-visualizações será adicionado aqui via JavaScript -->
                </div>
            </div>
        </div>

        <!-- Botões de Exportar e Pré-visualização -->
        <div class="flex flex-col md:flex-row flex-wrap justify-center gap-4 mt-8">
            <button id="full-preview-btn" class="bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg hover:bg-indigo-600 transition-colors transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed w-full sm:w-auto tooltip">
                Pré-visualização de Exportação
                <span class="tooltip-text">Visualizar todas as páginas antes de exportar</span>
            </button>
            <div class="flex flex-wrap justify-center gap-4">
                <button id="export-landscape-btn" class="bg-blue-500 text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg hover:bg-blue-600 transition-colors transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed w-full sm:w-auto tooltip">
                    Gerar PDF
                    <span class="tooltip-text">Exportar em formato PDF no modo paisagem</span>
                </button>
                <button id="export-landscape-jpg-btn" class="bg-green-500 text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg hover:bg-green-600 transition-colors transform hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed w-full sm:w-auto tooltip">
                    Gerar JPG
                    <span class="tooltip-text">Exportar em formato JPG no modo paisagem</span>
                </button>
            </div>
        </div>
        <div id="status-message" class="mt-4 text-center text-gray-600 font-medium"></div>
        
        <!-- Loading Overlay -->
        <div id="loading-overlay" class="loading-overlay hidden">
            <div class="spinner mb-3">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
            </div>
            <p id="loading-text">Processando...</p>
        </div>
    </div>

    <!-- Modal de Edição -->
    <div id="edit-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center p-2 sm:p-4 z-50">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-5xl h-full p-2 sm:p-6 transform transition-transform duration-300 flex flex-col">
            <!-- Área Principal de Edição e Painel de Ferramentas -->
            <div class="flex-1 flex flex-col lg:flex-row overflow-hidden p-2 sm:p-0">
                <!-- Área Principal do Canvas -->
                <div class="flex-1 flex items-center justify-center relative min-h-[30vh] lg:min-h-96">
                    <div id="editor-area" class="editor-container w-full h-full relative">
                        <canvas id="editor-canvas" class="w-full h-full maintain-aspect-ratio"></canvas>
                        <canvas id="drawing-canvas" class="drawing-canvas"></canvas>
                        <!-- Overlay com máscara e linhas tracejadas -->
                        <div id="mask-overlay" class="mask-overlay">
                            <!-- Linhas serão adicionadas via JavaScript -->
                        </div>
                    </div>
                </div>

                <!-- Painel de Controles da Ferramenta -->
                <div id="tool-controls-container" class="w-full lg:w-96 flex-shrink-0 lg:ml-6 mt-4 lg:mt-0 p-2 border-t lg:border-t-0 lg:border-l border-gray-200 overflow-y-auto">
                    <!-- Controles da Ferramenta de Zoom -->
                    <div id="zoom-controls" class="hidden">
                        <h3 class="text-xl font-bold mb-2 text-center lg:text-left">Ajustar Zoom</h3>
                        <p class="text-sm text-gray-600 mb-4 text-center lg:text-left">Ajuste o zoom para enquadrar a imagem como desejar.</p>
                        
                        <div class="flex items-center justify-between mb-4">
                            <button id="zoom-out-btn" class="zoom-btn bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition-colors">
                                -
                            </button>
                            
                            <div class="flex-1 mx-4">
                                <input type="range" id="zoom-slider" min="50" max="300" value="100" class="w-full accent-blue-500 realtime-preview">
                                <div class="flex justify-between text-xs text-gray-500 mt-1">
                                    <span>50%</span>
                                    <span id="zoom-value">100%</span>
                                    <span>300%</span>
                                </div>
                            </div>
                            
                            <button id="zoom-in-btn" class="zoom-btn bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition-colors">
                                +
                            </button>
                        </div>
                        
                        <div class="flex justify-center space-x-2 mb-4">
                            <button id="zoom-reset-btn" class="bg-gray-200 text-gray-700 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition-colors">
                                Redefinir
                            </button>
                        </div>
                        
                        <div class="flex justify-center lg:justify-end space-x-4 mt-4">
                            <button id="discard-zoom-btn" class="bg-gray-400 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-gray-500 transition-colors">
                                Descartar Alterações
                            </button>
                            <button id="save-zoom-btn" class="bg-blue-500 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-blue-600 transition-colors">
                                Salvar Alterações
                            </button>
                        </div>
                    </div>

                    <!-- Controles da Ferramenta de Legenda - MODIFICADO -->
                    <div id="caption-controls" class="hidden">
                        <h3 class="text-xl font-bold mb-2 text-center lg:text-left">Editor de Legendas</h3>
                        
                        <div class="caption-controls">
                            <div class="caption-control-group">
                                <label class="text-gray-700 text-sm">Texto:</label>
                                <textarea id="caption-text-input" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50 realtime-preview" rows="3"></textarea>
                            </div>
                            
                            <div class="caption-control-group">
                                <label class="text-gray-700 text-sm">Cor do Texto:</label>
                                <div class="flex items-center gap-2">
                                    <input type="color" id="caption-color-input" class="mt-1 block h-8 rounded-md border-gray-300 realtime-preview" value="#000000">
                                    <div class="color-preview" id="text-color-preview" style="background-color: #000000;"></div>
                                </div>
                            </div>
                            
                            <div class="caption-control-group">
                                <label class="text-gray-700 text-sm">Cor do Contorno:</label>
                                <div class="flex items-center gap-2">
                                    <input type="color" id="caption-outline-color-input" class="mt-1 block h-8 rounded-md border-gray-300 realtime-preview" value="#FFFFFF">
                                    <div class="color-preview" id="outline-color-preview" style="background-color: #FFFFFF;"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="caption-controls mt-3">
                            <div class="caption-control-group">
                                <label class="text-gray-700 text-sm">Tamanho da Fonte:</label>
                                <input type="range" id="caption-size-slider" min="10" max="100" value="20" class="mt-1 w-full accent-blue-500 realtime-preview">
                                <p class="text-right text-sm text-gray-500" id="caption-size-value">20 px</p>
                            </div>
                            
                            <div class="caption-control-group">
                                <label class="text-gray-700 text-sm">Espessura do Contorno:</label>
                                <input type="range" id="caption-stroke-slider" min="0" max="100" value="0" class="mt-1 w-full accent-blue-500 realtime-preview">
                                <p class="text-right text-sm text-gray-500" id="caption-stroke-value">0 px</p>
                            </div>
                            
                            <div class="caption-control-group">
                                <label class="text-gray-700 text-sm">Fonte:</label>
                                <select id="caption-font-select" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm realtime-preview">
                                    <option value="Valentine Baby, sans-serif">Valentine Baby</option>
                                    <option value="'Dancing Script', cursive">Dancing Script</option>
                                    <option value="'Pacifico', cursive">Pacifico</option>
                                    <option value="'Shadows Into Light', cursive">Shadows Into Light</option>
                                    <option value="'Indie Flower', cursive">Indie Flower</option>
                                    <option value="Inter, sans-serif">Inter</option>
                                    <option value="Arial, sans-serif">Arial</option>
                                    <option value="Verdana, sans-serif">Verdana</option>
                                    <option value="'Times New Roman', serif">Times New Roman</option>
                                    <option value="'Courier New', monospace">Courier New</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="caption-controls mt-3">
                            <div class="caption-control-group">
                                <label class="text-gray-700 text-sm">Alinhamento:</label>
                                <div class="flex gap-2 mt-1">
                                    <button class="alignment-btn p-2 bg-gray-200 rounded" data-align="left" title="Alinhar à esquerda">
                                        <i class="fas fa-align-left"></i>
                                    </button>
                                    <button class="alignment-btn p-2 bg-gray-200 rounded" data-align="center" title="Centralizar">
                                        <i class="fas fa-align-center"></i>
                                    </button>
                                    <button class="alignment-btn p-2 bg-gray-200 rounded" data-align="right" title="Alinhar à direita">
                                        <i class="fas fa-align-right"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Botão de reset para legendas -->
                        <div class="flex justify-center mt-4">
                            <button id="reset-caption-btn" class="reset-btn font-semibold py-2 px-4 rounded-lg">
                                Resetar Legendas
                            </button>
                        </div>
                        
                        <div class="flex justify-center lg:justify-end space-x-4 mt-4">
                            <button id="discard-caption-btn" class="bg-gray-400 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-gray-500 transition-colors">
                                Descartar
                            </button>
                            <button id="save-caption-btn" class="bg-blue-500 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-blue-600 transition-colors">
                                Salvar
                            </button>
                        </div>
                    </div>

                    <!-- Controles de Edição de Fundo -->
                    <div id="background-controls" class="hidden">
                        <h3 class="text-xl font-bold mb-2 text-center lg:text-left">Editar Fundo</h3>
                        <p class="text-sm text-gray-600 mb-4 text-center lg:text-left">Ajuste o desfoque e o redimensionamento do fundo da imagem.</p>
                        
                        <div class="mb-4">
                            <label class="block text-gray-700 text-sm mb-2">Carregar foto de fundo:</label>
                            <input type="file" id="background-upload" accept="image/*" class="hidden">
                            <button id="background-upload-btn" class="bg-gray-200 text-gray-700 font-semibold py-2 px-4 rounded-lg w-full mb-2">
                                Selecionar Foto
                            </button>
                            <button id="use-same-photo-btn" class="bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg w-full">
                                Usar mesma foto como fundo
                            </button>
                        </div>
                        
                        <label class="block mb-4">
                            <span class="text-gray-700">Intensidade do Desfoque:</span>
                            <input type="range" id="blur-slider" min="0" max="250" value="15" class="mt-1 w-full accent-indigo-500 realtime-preview">
                            <p class="text-right text-sm text-gray-500" id="blur-value">15 px</p>
                        </label>
                        <label class="block mb-4">
                            <span class="text-gray-700">Redimensionar Fundo (%):</span>
                            <input type="range" id="background-size-slider" min="100" max="500" value="100" class="mt-1 w-full accent-indigo-500 realtime-preview">
                            <p class="text-right text-sm text-gray-500" id="background-size-value">100 %</p>
                        </label>
                        
                        <!-- Novos controles de edição para o fundo -->
                        <div class="advanced-controls">
                            <div class="advanced-control-group">
                                <label>Matriz</label>
                                <input type="range" id="matrix-slider" min="-50" max="50" value="0" class="realtime-preview">
                            </div>
                            <div class="advanced-control-group">
                                <label>Saturação</label>
                                <input type="range" id="saturation-slider" min="-50" max="50" value="0" class="realtime-preview">
                            </div>
                            <div class="advanced-control-group">
                                <label>Brilho</label>
                                <input type="range" id="brightness-slider" min="-50" max="50" value="0" class="realtime-preview">
                            </div>
                            <div class="advanced-control-group">
                                <label>Contraste</label>
                                <input type="range" id="contrast-slider" min="-50" max="50" value="0" class="realtime-preview">
                            </div>
                            <div class="advanced-control-group">
                                <label>Nitidez</label>
                                <input type="range" id="sharpness-slider" min="-50" max="50" value="0" class="realtime-preview">
                            </div>
                            <div class="advanced-control-group">
                                <label>Desfoque</label>
                                <input type="range" id="blur-advanced-slider" min="-50" max="50" value="0" class="realtime-preview">
                            </div>
                        </div>
                        
                        <div class="flex justify-center lg:justify-end space-x-4 mt-4">
                            <button id="discard-background-btn" class="bg-gray-400 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-gray-500 transition-colors">
                                Descartar Alterações
                            </button>
                            <button id="save-background-btn" class="bg-blue-500 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-blue-600 transition-colors">
                                Salvar Alterações
                            </button>
                        </div>
                    </div>

                    <!-- Novos controles de edição avançada -->
                    <div id="advanced-controls" class="hidden">
                        <h3 class="text-xl font-bold mb-2 text-center lg:text-left">Ajustes Avançados</h3>
                        
                        <div class="advanced-controls">
                            <div class="advanced-control-group">
                                <label>Matriz</label>
                                <input type="range" id="matrix-slider-main" min="-50" max="50" value="0" class="realtime-preview">
                            </div>
                            <div class="advanced-control-group">
                                <label>Saturação</label>
                                <input type="range" id="saturation-slider-main" min="-50" max="50" value="0" class="realtime-preview">
                            </div>
                            <div class="advanced-control-group">
                                <label>Brilho</label>
                                <input type="range" id="brightness-slider-main" min="-50" max="50" value="0" class="realtime-preview">
                            </div>
                            <div class="advanced-control-group">
                                <label>Contraste</label>
                                <input type="range" id="contrast-slider-main" min="-50" max="50" value="0" class="realtime-preview">
                            </div>
                            <div class="advanced-control-group">
                                <label>Nitidez</label>
                                <input type="range" id="sharpness-slider-main" min="-50" max="50" value="0" class="realtime-preview">
                            </div>
                            <div class="advanced-control-group">
                                <label>Desfoque</label>
                                <input type="range" id="blur-advanced-slider-main" min="-50" max="50" value="0" class="realtime-preview">
                            </div>
                        </div>
                        
                        <div class="flex justify-center lg:justify-end space-x-4 mt-4">
                            <button id="discard-advanced-btn" class="bg-gray-400 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-gray-500 transition-colors">
                                Descartar
                            </button>
                            <button id="save-advanced-btn" class="bg-blue-500 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-blue-600 transition-colors">
                                Salvar
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Botões de Ação do Modal - Fundo do painel de edição -->
            <div class="flex flex-col lg:flex-row justify-between items-center space-y-4 lg:space-y-0 lg:space-x-4 mt-6 border-t pt-4 border-gray-200">
                <div class="flex flex-wrap gap-2 w-full lg:w-auto">
                    <button id="back-btn" class="bg-blue-400 text-white font-semibold py-2 px-6 rounded-lg shadow-md hover:bg-blue-500 transition-colors w-full lg:w-auto">
                        Voltar
                    </button>
                    <button id="next-image-btn" class="next-image-btn font-semibold py-2 px-6 rounded-lg shadow-md transition-colors w-full lg:w-auto">
                        Editar Próxima Foto
                    </button>
                    <button id="reset-all-btn" class="reset-btn font-semibold py-2 px-6 rounded-lg shadow-md transition-colors w-full lg:w-auto">
                        Resetar Tudo
                    </button>
                </div>
                <div class="flex flex-wrap justify-center lg:justify-end gap-2 w-full lg:w-auto">
                    <button id="tool-zoom-btn" class="tool-btn bg-blue-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors flex-1">
                        Zoom
                    </button>
                    <button id="tool-caption-btn" class="tool-btn bg-gray-200 text-gray-700 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition-colors flex-1">
                        Legendas
                    </button>
                    <button id="tool-background-btn" class="tool-btn bg-gray-200 text-gray-700 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition-colors flex-1">
                        Editar Fundo
                    </button>
                    <button id="tool-advanced-btn" class="tool-btn bg-gray-200 text-gray-700 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300 transition-colors flex-1">
                        Ajustes Avançados
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Novo Modal de Pré-visualização de Exportação -->
    <div id="full-preview-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden flex items-center justify-center p-2 sm:p-4 z-50">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-5xl h-full p-2 sm:p-6 transform transition-transform duration-300 flex flex-col">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-2xl font-bold">Pré-visualização de Exportação</h2>
                <button id="close-preview-btn" class="bg-gray-400 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-gray-500 transition-colors">
                    Fechar
                </button>
            </div>

            <!-- Controles de navegação do carrossel -->
            <div id="full-preview-nav" class="flex justify-between items-center mb-4">
                <button id="prev-page-btn" class="bg-gray-200 text-gray-800 p-2 rounded-full hover:bg-gray-300 disabled:opacity-50 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                    </svg>
                </button>
                <span id="page-indicator" class="text-xl font-bold text-gray-700"></span>
                <button id="next-page-btn" class="bg-gray-200 text-gray-800 p-2 rounded-full hover:bg-gray-300 disabled:opacity-50 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                </button>
            </div>

            <!-- MODIFICADO: Área de pré-visualização em grade 2x4 -->
            <div id="full-preview-area" class="grid grid-cols-2 gap-4 overflow-y-auto">
                <!-- As imagens de pré-visualização serão adicionadas aqui via JavaScript -->
            </div>
            
            <div class="flex flex-col md:flex-row flex-wrap justify-center gap-4 mt-8 border-t pt-4">
                <div class="flex flex-wrap justify-center gap-4">
                    <button id="modal-export-landscape-btn" class="bg-blue-500 text-white font-bold py-4 px-10 rounded-lg text-xl shadow-lg hover:bg-blue-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed">
                        Gerar PDF
                    </button>
                    <button id="modal-export-landscape-jpg-btn" class="bg-green-500 text-white font-bold py-4 px-10 rounded-lg text-xl shadow-lg hover:bg-green-600 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed">
                        Gerar JPG
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Main application script
        window.onload = function() {
            const { jsPDF } = window.jspdf;

            // Elementos do DOM
            const imageUpload = document.getElementById('image-upload');
            const imageGallery = document.getElementById('image-gallery');
            const clearAllBtn = document.getElementById('clear-all-btn');
            const exportLandscapeBtn = document.getElementById('export-landscape-btn');
            const exportLandscapeJpgBtn = document.getElementById('export-landscape-jpg-btn');
            const statusMessage = document.getElementById('status-message');
            const previewGallery = document.getElementById('preview-gallery');
            const editModal = document.getElementById('edit-modal');
            const backBtn = document.getElementById('back-btn');
            const editorCanvas = document.getElementById('editor-canvas');
            const drawingCanvas = document.getElementById('drawing-canvas');
            const toolZoomBtn = document.getElementById('tool-zoom-btn');
            const toolCaptionBtn = document.getElementById('tool-caption-btn');
            const toolBackgroundBtn = document.getElementById('tool-background-btn');
            const toolAdvancedBtn = document.getElementById('tool-advanced-btn');
            const zoomControls = document.getElementById('zoom-controls');
            const captionControls = document.getElementById('caption-controls');
            const backgroundControls = document.getElementById('background-controls');
            const advancedControls = document.getElementById('advanced-controls');
            const maskOverlay = document.getElementById('mask-overlay');
            const zoomSlider = document.getElementById('zoom-slider');
            const zoomValue = document.getElementById('zoom-value');
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const zoomResetBtn = document.getElementById('zoom-reset-btn');
            const saveZoomBtn = document.getElementById('save-zoom-btn');
            const discardZoomBtn = document.getElementById('discard-zoom-btn');
            const captionTextInput = document.getElementById('caption-text-input');
            const captionColorInput = document.getElementById('caption-color-input');
            const captionOutlineColorInput = document.getElementById('caption-outline-color-input');
            const captionSizeSlider = document.getElementById('caption-size-slider');
            const captionSizeValueText = document.getElementById('caption-size-value');
            const captionStrokeSlider = document.getElementById('caption-stroke-slider');
            const captionStrokeValueText = document.getElementById('caption-stroke-value');
            const captionFontSelect = document.getElementById('caption-font-select');
            const blurSlider = document.getElementById('blur-slider');
            const blurValueText = document.getElementById('blur-value');
            const backgroundSizeSlider = document.getElementById('background-size-slider');
            const backgroundSizeValueText = document.getElementById('background-size-value');
            const editorArea = document.getElementById('editor-area');
            const uploadSection = document.getElementById('upload-section');
            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingText = document.getElementById('loading-text');
            const gridTypeSelect = document.getElementById('grid-type-select');
            const gridOptions = document.querySelectorAll('.grid-option');
            const nextImageBtn = document.getElementById('next-image-btn');
            const resetAllBtn = document.getElementById('reset-all-btn');
            const resetCaptionBtn = document.getElementById('reset-caption-btn');
            const backgroundUpload = document.getElementById('background-upload');
            const backgroundUploadBtn = document.getElementById('background-upload-btn');
            const useSamePhotoBtn = document.getElementById('use-same-photo-btn');
            const saveCaptionBtn = document.getElementById('save-caption-btn');
            const discardCaptionBtn = document.getElementById('discard-caption-btn');
            const saveBackgroundBtn = document.getElementById('save-background-btn');
            const discardBackgroundBtn = document.getElementById('discard-background-btn');
            const saveAdvancedBtn = document.getElementById('save-advanced-btn');
            const discardAdvancedBtn = document.getElementById('discard-advanced-btn');

            // Novos botões e modais de pré-visualização
            const fullPreviewBtn = document.getElementById('full-preview-btn');
            const fullPreviewModal = document.getElementById('full-preview-modal');
            const closePreviewBtn = document.getElementById('close-preview-btn');
            const fullPreviewArea = document.getElementById('full-preview-area');
            const modalExportLandscapeBtn = document.getElementById('modal-export-landscape-btn');
            const modalExportLandscapeJpgBtn = document.getElementById('modal-export-landscape-jpg-btn');
            
            // Novos elementos de navegação
            const fullPreviewNav = document.getElementById('full-preview-nav');
            const prevPageBtn = document.getElementById('prev-page-btn');
            const nextPageBtn = document.getElementById('next-page-btn');
            const pageIndicator = document.getElementById('page-indicator');
            
            // Elementos do editor de legendas
            const alignmentButtons = document.querySelectorAll('.alignment-btn');
            const textColorPreview = document.getElementById('text-color-preview');
            const outlineColorPreview = document.getElementById('outline-color-preview');

            // Controles avançados
            const matrixSlider = document.getElementById('matrix-slider');
            const saturationSlider = document.getElementById('saturation-slider');
            const brightnessSlider = document.getElementById('brightness-slider');
            const contrastSlider = document.getElementById('contrast-slider');
            const sharpnessSlider = document.getElementById('sharpness-slider');
            const blurAdvancedSlider = document.getElementById('blur-advanced-slider');
            const matrixSliderMain = document.getElementById('matrix-slider-main');
            const saturationSliderMain = document.getElementById('saturation-slider-main');
            const brightnessSliderMain = document.getElementById('brightness-slider-main');
            const contrastSliderMain = document.getElementById('contrast-slider-main');
            const sharpnessSliderMain = document.getElementById('sharpness-slider-main');
            const blurAdvancedSliderMain = document.getElementById('blur-advanced-slider-main');

            const editorCtx = editorCanvas.getContext('2d');
            const drawingCtx = drawingCanvas.getContext('2d');

            let uploadedImages = [];
            let currentImageIndex = -1;
            let currentTool = null;
            let initialCanvasSize = { width: 0, height: 0 };
            let currentPageIndex = 0;
            let gridType = '2x4'; // Padrão: 2x4
            let isDragging = false;
            let selectedCaptionIndex = -1;
            let dragOffset = { x: 0, y: 0 };
            let isDrawing = false;
            let drawMode = null; // 'rectangle', 'circle'
            let startX, startY;
            let editHistory = [];
            let historyIndex = -1;

            // Dimensões da folha A4 em 300 DPI
            const A4_WIDTH_PX_LANDSCAPE = 3508;
            const A4_HEIGHT_PX_LANDSCAPE = 2480;
            
            // Dimensões de cada foto na grade (para 2x4)
            const IMAGE_WIDTH_PX_2x4 = 832.32;
            const IMAGE_HEIGHT_PX_2x4 = 1177.2;
            
            // Dimensões para outras grades
            const IMAGE_WIDTH_PX_2x2 = 1664.64;
            const IMAGE_HEIGHT_PX_2x2 = 2354.4;
            
            const IMAGE_WIDTH_PX_1x2 = 1664.64;
            const IMAGE_HEIGHT_PX_1x2 = 2354.4;

            // Dimensões para grade 3x3
            const IMAGE_WIDTH_PX_3x3 = 1102.67;
            const IMAGE_HEIGHT_PX_3x3 = 1102.67;

            const DEFAULT_BLUR = 30;
            const DEFAULT_BG_SIZE = 180;
            const BLUR_PADDING = 250;

            // Configuração das grades
            const gridConfigs = {
                '2x4': {
                    cols: 4,
                    rows: 2,
                    imageWidth: IMAGE_WIDTH_PX_2x4,
                    imageHeight: IMAGE_HEIGHT_PX_2x4,
                    horizontalSpacing: (A4_WIDTH_PX_LANDSCAPE - (4 * IMAGE_WIDTH_PX_2x4)) / 5,
                    verticalSpacing: (A4_HEIGHT_PX_LANDSCAPE - (2 * IMAGE_HEIGHT_PX_2x4)) / 3,
                    orientation: 'portrait'
                },
                '2x2': {
                    cols: 2,
                    rows: 2,
                    imageWidth: IMAGE_WIDTH_PX_2x2,
                    imageHeight: IMAGE_HEIGHT_PX_2x2,
                    horizontalSpacing: (A4_WIDTH_PX_LANDSCAPE - (2 * IMAGE_WIDTH_PX_2x2)) / 3,
                    verticalSpacing: (A4_HEIGHT_PX_LANDSCAPE - (2 * IMAGE_HEIGHT_PX_2x2)) / 3,
                    orientation: 'portrait'
                },
                '1x2': {
                    cols: 2,
                    rows: 1,
                    imageWidth: IMAGE_WIDTH_PX_1x2,
                    imageHeight: IMAGE_HEIGHT_PX_1x2,
                    horizontalSpacing: (A4_WIDTH_PX_LANDSCAPE - (2 * IMAGE_WIDTH_PX_1x2)) / 3,
                    verticalSpacing: (A4_HEIGHT_PX_LANDSCAPE - (1 * IMAGE_HEIGHT_PX_1x2)) / 2,
                    orientation: 'portrait'
                },
                '3x3': {
                    cols: 3,
                    rows: 3,
                    imageWidth: IMAGE_WIDTH_PX_3x3,
                    imageHeight: IMAGE_HEIGHT_PX_3x3,
                    horizontalSpacing: (A4_WIDTH_PX_LANDSCAPE - (3 * IMAGE_WIDTH_PX_3x3)) / 4,
                    verticalSpacing: (A4_HEIGHT_PX_LANDSCAPE - (3 * IMAGE_HEIGHT_PX_3x3)) / 4,
                    orientation: 'portrait'
                }
            };

            // Helper to get proportional image dimensions for drawing (object-fit: contain)
            const getProportionalContainDimensions = (imgWidth, imgHeight, boxWidth, boxHeight) => {
                const imageAspect = imgWidth / imgHeight;
                const boxAspect = boxWidth / boxHeight;
                let drawWidth, drawHeight, offsetX, offsetY;
                
                if (imageAspect > boxAspect) {
                    drawWidth = boxWidth;
                    drawHeight = boxWidth / imageAspect;
                    offsetX = 0;
                    offsetY = (boxHeight - drawHeight) / 2;
                } else {
                    drawHeight = boxHeight;
                    drawWidth = boxHeight * imageAspect;
                    offsetX = (boxWidth - drawWidth) / 2;
                    offsetY = 0;
                }
                return { drawWidth, drawHeight, offsetX, offsetY };
            };

            // Renders the image gallery with thumbnails and buttons
            const renderImages = () => {
                imageGallery.innerHTML = '';
                uploadedImages.forEach((image, index) => {
                    const card = document.createElement('div');
                    card.className = 'relative group w-full aspect-square rounded-xl overflow-hidden shadow-md border-2 border-gray-200 image-card';
                    card.innerHTML = `
                        <img src="${image.croppedUrl}" alt="Thumbnail" class="w-full h-full object-contain">
                        <div class="absolute inset-0 flex items-start justify-between p-2">
                            <!-- Ícone de Editar (canto superior esquerdo) -->
                            <button class="edit-btn bg-white/70 p-2 rounded-full shadow-md hover:bg-white transition-colors">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800" viewBox="0 0 20 20" fill="currentColor">
                                    <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zm-3.832 2.832l-3.35 3.35a2 2 0 00-.594 1.157l-.022.259a.5.5 0 00.174.457l1.242 1.242a.5.5 0 00.457.174l.259-.022c.433-.04.852-.164 1.242-.457l3.35-3.35-2.828-2.828z" />
                                </svg>
                            </button>
                            <!-- Ícone de Excluir (canto superior direito) -->
                            <button class="remove-btn bg-white/70 p-2 rounded-full shadow-md hover:bg-white transition-colors">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 10-2 0v6a1 1 0 102 0V8z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    `;
                    card.querySelector('.edit-btn').addEventListener('click', () => {
                        currentImageIndex = index;
                        openEditModal(image);
                    });
                    card.querySelector('.remove-btn').addEventListener('click', () => {
                        uploadedImages.splice(index, 1);
                        renderImages();
                        updateExportButtonState();
                    });
                    imageGallery.appendChild(card);
                });
                
                // Adicionar o cartão para adicionar novas fotos
                const addCard = document.createElement('div');
                addCard.className = 'w-full aspect-square rounded-xl border-2 border-dashed border-gray-300 flex items-center justify-center cursor-pointer hover:bg-gray-50 transition-colors';
                addCard.innerHTML = `
                    <span class="text-gray-400 text-6xl font-light">+</span>
                `;
                addCard.addEventListener('click', () => {
                    imageUpload.click();
                });
                imageGallery.appendChild(addCard);

                renderPreviewGallery('landscape');
            };

            // Update the state of the export button
            const updateExportButtonState = () => {
                const hasImages = uploadedImages.length > 0;
                exportLandscapeBtn.disabled = !hasImages;
                exportLandscapeJpgBtn.disabled = !hasImages;
                fullPreviewBtn.disabled = !hasImages;
                
                modalExportLandscapeBtn.disabled = !hasImages;
                modalExportLandscapeJpgBtn.disabled = !hasImages;

                renderPreviewGallery('landscape');

                // Oculta a seção de upload se houver imagens
                if (hasImages) {
                    uploadSection.classList.add('hidden');
                } else {
                    uploadSection.classList.remove('hidden');
                }
            };

            // Renders the A4 page preview gallery
            const renderPreviewGallery = (orientation) => {
                previewGallery.innerHTML = '';
                if (uploadedImages.length === 0) return;

                const config = gridConfigs[gridType];
                const IMAGES_PER_PAGE = config.cols * config.rows;
                const totalPages = Math.ceil(uploadedImages.length / IMAGES_PER_PAGE);

                for (let pageIndex = 0; pageIndex < totalPages; pageIndex++) {
                    const canvasWrapper = document.createElement('div');
                    canvasWrapper.className = 'preview-canvas-wrapper aspect-[1.414/1] relative';
                    const canvas = document.createElement('canvas');
                    const scale = 10;
                    const pageTotalWidth = A4_WIDTH_PX_LANDSCAPE;
                    const pageTotalHeight = A4_HEIGHT_PX_LANDSCAPE;
                    canvas.width = pageTotalWidth / scale;
                    canvas.height = pageTotalHeight / scale;

                    const zoomIndicator = document.createElement('div');
                    zoomIndicator.className = 'preview-zoom-indicator';
                    zoomIndicator.textContent = 'Zoom: 100%';
                    canvasWrapper.appendChild(canvas);
                    canvasWrapper.appendChild(zoomIndicator);
                    previewGallery.appendChild(canvasWrapper);

                    drawPageToCanvas(canvas, pageIndex, orientation);
                }
            };

            // Draws a single page to a given canvas
            const drawPageToCanvas = (canvas, pageIndex, orientation) => {
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const config = gridConfigs[gridType];
                const IMAGES_PER_PAGE = config.cols * config.rows;

                const pageTotalWidth = A4_WIDTH_PX_LANDSCAPE;
                const pageTotalHeight = A4_HEIGHT_PX_LANDSCAPE;
                const scaleFactor = canvas.width / pageTotalWidth;
                
                const startImageIndex = pageIndex * IMAGES_PER_PAGE;
                const endImageIndex = Math.min(startImageIndex + IMAGES_PER_PAGE, uploadedImages.length);
                const imagesToDraw = uploadedImages.slice(startImageIndex, endImageIndex);

                let imagePromiseChain = Promise.resolve();
                imagesToDraw.forEach((image, i) => {
                    imagePromiseChain = imagePromiseChain.then(() => {
                        const col = i % config.cols;
                        const row = Math.floor(i / config.cols);
                        
                        let xPos, yPos;
                        xPos = config.horizontalSpacing + col * (config.imageWidth + config.horizontalSpacing);
                        yPos = config.verticalSpacing + row * (config.imageHeight + config.verticalSpacing);

                        // Cria um canvas temporário que funciona como a "máscara"
                        const compositeCanvas = document.createElement('canvas');
                        compositeCanvas.width = config.imageWidth;
                        compositeCanvas.height = config.imageHeight;
                        const compositeCtx = compositeCanvas.getContext('2d');

                        return drawCompositeImage(compositeCtx, image, config)
                            .then(() => {
                                ctx.drawImage(compositeCanvas, xPos * scaleFactor, yPos * scaleFactor, config.imageWidth * scaleFactor, config.imageHeight * scaleFactor);
                            });
                    });
                });
            };

            // Draws a single image, its background and captions on a canvas
            const drawCompositeImage = (ctx, imageObject, config) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.src = imageObject.croppedUrl;

                    const bgImg = new Image();
                    bgImg.src = imageObject.blurredUrl;
                    
                    let imagesLoaded = 0;
                    const totalImages = (imageObject.blurredUrl && imageObject.blurRadius > 0) ? 2 : 1;

                    const checkReady = () => {
                        imagesLoaded++;
                        if (imagesLoaded === totalImages) {
                            // Draw background if it exists
                            if (imageObject.blurredUrl && imageObject.blurRadius > 0) {
                                const { drawWidth, drawHeight, offsetX, offsetY } = getProportionalContainDimensions(bgImg.width, bgImg.height, config.imageWidth, config.imageHeight);
                                const bgScale = imageObject.backgroundSize / 100;
                                const finalBgWidth = drawWidth * bgScale;
                                const finalBgHeight = drawHeight * bgScale;
                                const finalBgOffsetX = offsetX + (drawWidth - finalBgWidth) / 2;
                                const finalBgOffsetY = offsetY + (drawHeight - finalBgHeight) / 2;
                                ctx.drawImage(bgImg, finalBgOffsetX, finalBgOffsetY, finalBgWidth, finalBgHeight);
                            }

                            // Draw foreground image with zoom applied
                            const { drawWidth, drawHeight, offsetX, offsetY } = getProportionalContainDimensions(img.width, img.height, config.imageWidth, config.imageHeight);
                            
                            // Apply zoom if exists
                            let zoomFactor = 1;
                            if (imageObject.zoom && imageObject.zoom !== 100) {
                                zoomFactor = imageObject.zoom / 100;
                            }

                            const zoomedWidth = drawWidth * zoomFactor;
                            const zoomedHeight = drawHeight * zoomFactor;
                            const zoomOffsetX = offsetX - (zoomedWidth - drawWidth) / 2;
                            const zoomOffsetY = offsetY - (zoomedHeight - drawHeight) / 2;

                            ctx.drawImage(img, zoomOffsetX, zoomOffsetY, zoomedWidth, zoomedHeight);

                            // Draw captions
                            drawCaptionsOnCanvas(ctx, imageObject.captions, 0, 0, 1);
                            
                            // Draw drawings
                            if (imageObject.drawings && imageObject.drawings.length > 0) {
                                imageObject.drawings.forEach(drawing => {
                                    ctx.fillStyle = drawing.color;
                                    if (drawing.type === 'rectangle') {
                                        ctx.fillRect(drawing.x, drawing.y, drawing.width, drawing.height);
                                    } else if (drawing.type === 'circle') {
                                        ctx.beginPath();
                                        ctx.arc(drawing.x + drawing.width/2, drawing.y + drawing.height/2, drawing.width/2, 0, 2 * Math.PI);
                                        ctx.fill();
                                    }
                                });
                            }
                            
                            resolve();
                        }
                    };

                    img.onload = checkReady;
                    img.onerror = resolve;
                    if (totalImages === 2) {
                        bgImg.onload = checkReady;
                        bgImg.onerror = resolve;
                    } else {
                        checkReady();
                    }
                });
            };

            // Function to open the main edit modal
            const openEditModal = (image) => {
                editModal.classList.remove('hidden');
                // Salvar estado atual no histórico
                saveToHistory();

                // Load existing data
                const existingCaptions = image.captions || [];
                image.tempCaptions = JSON.parse(JSON.stringify(existingCaptions));
                image.tempBlurRadius = image.blurRadius;
                image.tempBackgroundSize = image.backgroundSize;
                image.tempZoom = image.zoom || 100;
                image.tempDrawings = image.drawings || [];
                image.tempMatrix = image.matrix || 0;
                image.tempSaturation = image.saturation || 0;
                image.tempBrightness = image.brightness || 0;
                image.tempContrast = image.contrast || 0;
                image.tempSharpness = image.sharpness || 0;
                image.tempBlurAdvanced = image.blurAdvanced || 0;

                blurSlider.value = image.tempBlurRadius;
                blurValueText.textContent = `${image.tempBlurRadius} px`;
                backgroundSizeSlider.value = image.tempBackgroundSize;
                backgroundSizeValueText.textContent = `${image.tempBackgroundSize} %`;
                zoomSlider.value = image.tempZoom;
                zoomValue.textContent = `${image.tempZoom}%`;

                // Configurar controles avançados
                matrixSlider.value = image.tempMatrix;
                saturationSlider.value = image.tempSaturation;
                brightnessSlider.value = image.tempBrightness;
                contrastSlider.value = image.tempContrast;
                sharpnessSlider.value = image.tempSharpness;
                blurAdvancedSlider.value = image.tempBlurAdvanced;

                matrixSliderMain.value = image.tempMatrix;
                saturationSliderMain.value = image.tempSaturation;
                brightnessSliderMain.value = image.tempBrightness;
                contrastSliderMain.value = image.tempContrast;
                sharpnessSliderMain.value = image.tempSharpness;
                blurAdvancedSliderMain.value = image.tempBlurAdvanced;

                initialCanvasSize = { width: image.imgElement.width, height: image.imgElement.height };

                // Resize and draw canvas based on container
                resizeCanvasAndDraw();

                // Create mask lines
                createMaskLines();

                // Listen for window resize to make the canvas responsive
                window.addEventListener('resize', resizeCanvasAndDraw);
            };

            // Save current state to history for undo functionality
            const saveToHistory = () => {
                if (currentImageIndex >= 0) {
                    const image = uploadedImages[currentImageIndex];
                    // Limitar o histórico aos últimos 20 estados
                    if (editHistory.length >= 20) {
                        editHistory.shift();
                    }
                    editHistory.push(JSON.parse(JSON.stringify({
                        captions: image.captions,
                        drawings: image.drawings,
                        blurRadius: image.blurRadius,
                        backgroundSize: image.backgroundSize,
                        zoom: image.zoom,
                        matrix: image.matrix,
                        saturation: image.saturation,
                        brightness: image.brightness,
                        contrast: image.contrast,
                        sharpness: image.sharpness,
                        blurAdvanced: image.blurAdvanced
                    })));
                    historyIndex = editHistory.length - 1;
                }
            };

            // Undo last action
            const undoLastAction = () => {
                if (historyIndex > 0) {
                    historyIndex--;
                    const previousState = editHistory[historyIndex];
                    const image = uploadedImages[currentImageIndex];
                    
                    // Restaurar estado anterior
                    image.captions = JSON.parse(JSON.stringify(previousState.captions));
                    image.drawings = JSON.parse(JSON.stringify(previousState.drawings));
                    image.blurRadius = previousState.blurRadius;
                    image.backgroundSize = previousState.backgroundSize;
                    image.zoom = previousState.zoom;
                    image.matrix = previousState.matrix;
                    image.saturation = previousState.saturation;
                    image.brightness = previousState.brightness;
                    image.contrast = previousState.contrast;
                    image.sharpness = previousState.sharpness;
                    image.blurAdvanced = previousState.blurAdvanced;
                    
                    // Atualizar controles
                    blurSlider.value = image.blurRadius;
                    blurValueText.textContent = `${image.blurRadius} px`;
                    backgroundSizeSlider.value = image.backgroundSize;
                    backgroundSizeValueText.textContent = `${image.backgroundSize} %`;
                    zoomSlider.value = image.zoom;
                    zoomValue.textContent = `${image.zoom}%`;
                    
                    matrixSlider.value = image.matrix;
                    saturationSlider.value = image.saturation;
                    brightnessSlider.value = image.brightness;
                    contrastSlider.value = image.contrast;
                    sharpnessSlider.value = image.sharpness;
                    blurAdvancedSlider.value = image.blurAdvanced;
                    
                    matrixSliderMain.value = image.matrix;
                    saturationSliderMain.value = image.saturation;
                    brightnessSliderMain.value = image.brightness;
                    contrastSliderMain.value = image.contrast;
                    sharpnessSliderMain.value = image.sharpness;
                    blurAdvancedSliderMain.value = image.blurAdvanced;
                    
                    // Redesenhar
                    redrawEditorCanvas();
                }
            };

            // Create mask lines for the editor
            const createMaskLines = () => {
                maskOverlay.innerHTML = '';
                
                // Create vertical lines
                const config = gridConfigs[gridType];
                for (let i = 1; i < config.cols; i++) {
                    const line = document.createElement('div');
                    line.className = 'mask-line vertical';
                    line.style.left = `${(i * (100 / config.cols))}%`;
                    maskOverlay.appendChild(line);
                }
                
                // Create horizontal lines
                for (let i = 1; i < config.rows; i++) {
                    const line = document.createElement('div');
                    line.className = 'mask-line horizontal';
                    line.style.top = `${(i * (100 / config.rows))}%`;
                    maskOverlay.appendChild(line);
                }
            };

            // Resizes the canvas to fit its container while maintaining aspect ratio
            const resizeCanvasAndDraw = () => {
                const containerRect = editorArea.getBoundingClientRect();
                const containerWidth = containerRect.width;
                const containerHeight = containerRect.height;
                const image = uploadedImages[currentImageIndex].imgElement;

                let canvasWidth, canvasHeight;
                const imageAspect = image.width / image.height;
                const containerAspect = containerWidth / containerHeight;

                if (containerAspect > imageAspect) {
                    canvasHeight = containerHeight;
                    canvasWidth = canvasHeight * imageAspect;
                } else {
                    canvasWidth = containerWidth;
                    canvasHeight = canvasWidth / imageAspect;
                }

                editorCanvas.width = canvasWidth;
                editorCanvas.height = canvasHeight;
                drawingCanvas.width = canvasWidth;
                drawingCanvas.height = canvasHeight;

                // Redraw canvas with temp data
                redrawEditorCanvas();
            };

            // Redraws the editing canvas based on current state
            const redrawEditorCanvas = () => {
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                
                const image = uploadedImages[currentImageIndex];

                // Draw background if needed
                if (currentTool === 'background' && image.blurredUrl) {
                    const blurredImg = new Image();
                    blurredImg.src = image.blurredUrl;
                    blurredImg.onload = () => {
                        const { drawWidth, drawHeight, offsetX, offsetY } = getProportionalContainDimensions(blurredImg.width, blurredImg.height, editorCanvas.width, editorCanvas.height);
                        const bgScale = image.tempBackgroundSize / 100;
                        const bgWidth = drawWidth * bgScale;
                        const bgHeight = drawHeight * bgScale;
                        const bgOffsetX = offsetX + (drawWidth - bgWidth) / 2;
                        const bgOffsetY = offsetY + (drawHeight - bgHeight) / 2;

                        editorCtx.drawImage(blurredImg, bgOffsetX, bgOffsetY, bgWidth, bgHeight);
                    };
                } else {
                    // Draw foreground image with zoom applied
                    const { drawWidth, drawHeight, offsetX, offsetY } = getProportionalContainDimensions(image.imgElement.width, image.imgElement.height, editorCanvas.width, editorCanvas.height);
                    
                    // Apply zoom if exists
                    let zoomFactor = 1;
                    if (image.tempZoom && image.tempZoom !== 100) {
                        zoomFactor = image.tempZoom / 100;
                    }

                    const zoomedWidth = drawWidth * zoomFactor;
                    const zoomedHeight = drawHeight * zoomFactor;
                    const zoomOffsetX = offsetX - (zoomedWidth - drawWidth) / 2;
                    const zoomOffsetY = offsetY - (zoomedHeight - drawHeight) / 2;

                    editorCtx.drawImage(image.imgElement, zoomOffsetX, zoomOffsetY, zoomedWidth, zoomedHeight);
                    
                    // Draw captions
                    drawCaptionsOnCanvas(editorCtx, image.tempCaptions, offsetX, offsetY, drawWidth / image.imgElement.width);
                    
                    // Draw drawings
                    if (image.tempDrawings && image.tempDrawings.length > 0) {
                        const scale = drawWidth / image.imgElement.width;
                        image.tempDrawings.forEach(drawing => {
                            editorCtx.fillStyle = drawing.color;
                            if (drawing.type === 'rectangle') {
                                editorCtx.fillRect(offsetX + drawing.x * scale, offsetY + drawing.y * scale, drawing.width * scale, drawing.height * scale);
                            } else if (drawing.type === 'circle') {
                                editorCtx.beginPath();
                                editorCtx.arc(
                                    offsetX + (drawing.x + drawing.width/2) * scale, 
                                    offsetY + (drawing.y + drawing.height/2) * scale, 
                                    drawing.width/2 * scale, 
                                    0, 
                                    2 * Math.PI
                                );
                                editorCtx.fill();
                            }
                        });
                    }
                }
            };

            // Draws captions on a given canvas
            const drawCaptionsOnCanvas = (ctx, captions, xOffset = 0, yOffset = 0, scale = 1) => {
                captions.forEach((caption, index) => {
                    ctx.font = `${caption.size * scale}px ${caption.font}`;
                    ctx.fillStyle = caption.color;
                    ctx.strokeStyle = caption.outlineColor;
                    ctx.lineWidth = caption.strokeWidth * scale;
                    ctx.lineJoin = 'round';
                    
                    // Calcular largura do texto para alinhamento
                    const textWidth = ctx.measureText(caption.text).width;
                    let xPos = xOffset + caption.x * scale;
                    
                    // Aplicar alinhamento
                    if (caption.align === 'center') {
                        xPos = xOffset + (initialCanvasSize.width * scale - textWidth) / 2;
                    } else if (caption.align === 'right') {
                        xPos = xOffset + initialCanvasSize.width * scale - textWidth - 10;
                    }
                    
                    ctx.strokeText(caption.text, xPos, yOffset + caption.y * scale);
                    ctx.fillText(caption.text, xPos, yOffset + caption.y * scale);
                    
                    // Desenhar caixa de seleção se estiver selecionada
                    if (index === selectedCaptionIndex && currentTool === 'caption') {
                        ctx.strokeStyle = '#3b82f6';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(
                            xPos - 5, 
                            yOffset + caption.y * scale - caption.size * scale - 5, 
                            textWidth + 10, 
                            caption.size * scale + 10
                        );
                        ctx.setLineDash([]);
                    }
                });
            };

            // Handles tool selection
            const setTool = (toolName) => {
                currentTool = toolName;
                zoomControls.classList.add('hidden');
                captionControls.classList.add('hidden');
                backgroundControls.classList.add('hidden');
                advancedControls.classList.add('hidden');

                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.remove('bg-blue-500', 'text-white');
                    btn.classList.add('bg-gray-200', 'text-gray-700');
                });

                const image = uploadedImages[currentImageIndex];

                if (toolName === 'zoom') {
                    zoomControls.classList.remove('hidden');
                    toolZoomBtn.classList.remove('bg-gray-200', 'text-gray-700');
                    toolZoomBtn.classList.add('bg-blue-500', 'text-white');
                    
                    // Initialize zoom if not exists
                    if (image.tempZoom === undefined) {
                        image.tempZoom = 100;
                    }
                    zoomSlider.value = image.tempZoom;
                    zoomValue.textContent = `${image.tempZoom}%`;
                    
                    redrawEditorCanvas();
                } else if (toolName === 'caption') {
                    captionControls.classList.remove('hidden');
                    toolCaptionBtn.classList.remove('bg-gray-200', 'text-gray-700');
                    toolCaptionBtn.classList.add('bg-blue-500', 'text-white');

                    if (image.tempCaptions.length === 0) {
                        image.tempCaptions.push({
                            text: 'Sua Legenda',
                            x: 50,
                            y: initialCanvasSize.height - 50,
                            color: '#000000',
                            outlineColor: '#FFFFFF',
                            size: 20,
                            strokeWidth: 0,
                            font: 'Valentine Baby, sans-serif',
                            align: 'left'
                        });
                    }
                    
                    // Selecionar a primeira legenda por padrão
                    selectedCaptionIndex = 0;
                    const caption = image.tempCaptions[selectedCaptionIndex];
                    
                    captionTextInput.value = caption.text;
                    captionColorInput.value = caption.color;
                    captionOutlineColorInput.value = caption.outlineColor;
                    captionSizeSlider.value = caption.size;
                    captionSizeValueText.textContent = `${caption.size} px`;
                    captionStrokeSlider.value = caption.strokeWidth;
                    captionStrokeValueText.textContent = `${caption.strokeWidth} px`;
                    captionFontSelect.value = caption.font;
                    
                    // Atualizar visualização de cores
                    textColorPreview.style.backgroundColor = caption.color;
                    outlineColorPreview.style.backgroundColor = caption.outlineColor;
                    
                    addCaptionRealtimePreview();
                    
                    redrawEditorCanvas();
                } else if (toolName === 'background') {
                    backgroundControls.classList.remove('hidden');
                    toolBackgroundBtn.classList.remove('bg-gray-200', 'text-gray-700');
                    toolBackgroundBtn.classList.add('bg-blue-500', 'text-white');
                    
                    addBackgroundRealtimePreview();
                    
                    redrawEditorCanvas();
                } else if (toolName === 'advanced') {
                    advancedControls.classList.remove('hidden');
                    toolAdvancedBtn.classList.remove('bg-gray-200', 'text-gray-700');
                    toolAdvancedBtn.classList.add('bg-blue-500', 'text-white');
                    
                    addAdvancedRealtimePreview();
                    
                    redrawEditorCanvas();
                }
            };

            // Adiciona preview em tempo real para controles de legenda
            const addCaptionRealtimePreview = () => {
                const realtimeElements = document.querySelectorAll('#caption-controls .realtime-preview');
                realtimeElements.forEach(element => {
                    element.addEventListener('input', () => {
                        if (uploadedImages[currentImageIndex].tempCaptions.length > 0 && selectedCaptionIndex >= 0) {
                            const caption = uploadedImages[currentImageIndex].tempCaptions[selectedCaptionIndex];
                            caption.text = captionTextInput.value;
                            caption.color = captionColorInput.value;
                            caption.outlineColor = captionOutlineColorInput.value;
                            caption.size = parseInt(captionSizeSlider.value);
                            caption.strokeWidth = parseInt(captionStrokeSlider.value);
                            caption.font = captionFontSelect.value;
                            
                            // Atualizar visualização de cores
                            textColorPreview.style.backgroundColor = caption.color;
                            outlineColorPreview.style.backgroundColor = caption.outlineColor;
                            
                            captionSizeValueText.textContent = `${caption.size} px`;
                            captionStrokeValueText.textContent = `${caption.strokeWidth} px`;
                            
                            redrawEditorCanvas();
                        }
                    });
                });
            };

            // Adiciona preview em tempo real para controles de fundo
            const addBackgroundRealtimePreview = () => {
                const realtimeElements = document.querySelectorAll('#background-controls .realtime-preview');
                realtimeElements.forEach(element => {
                    element.addEventListener('input', () => {
                        const image = uploadedImages[currentImageIndex];
                        image.tempBlurRadius = parseInt(blurSlider.value);
                        image.tempBackgroundSize = parseInt(backgroundSizeSlider.value);
                        image.tempMatrix = parseInt(matrixSlider.value);
                        image.tempSaturation = parseInt(saturationSlider.value);
                        image.tempBrightness = parseInt(brightnessSlider.value);
                        image.tempContrast = parseInt(contrastSlider.value);
                        image.tempSharpness = parseInt(sharpnessSlider.value);
                        image.tempBlurAdvanced = parseInt(blurAdvancedSlider.value);
                        
                        blurValueText.textContent = `${image.tempBlurRadius} px`;
                        backgroundSizeValueText.textContent = `${image.tempBackgroundSize} %`;
                        
                        if (image.tempBlurRadius > 0) {
                            applyBlur(image.imgElement, image, image.tempBlurRadius);
                        }
                        redrawEditorCanvas();
                    });
                });
            };

            // Adiciona preview em tempo real para controles avançados
            const addAdvancedRealtimePreview = () => {
                const realtimeElements = document.querySelectorAll('#advanced-controls .realtime-preview');
                realtimeElements.forEach(element => {
                    element.addEventListener('input', () => {
                        const image = uploadedImages[currentImageIndex];
                        image.tempMatrix = parseInt(matrixSliderMain.value);
                        image.tempSaturation = parseInt(saturationSliderMain.value);
                        image.tempBrightness = parseInt(brightnessSliderMain.value);
                        image.tempContrast = parseInt(contrastSliderMain.value);
                        image.tempSharpness = parseInt(sharpnessSliderMain.value);
                        image.tempBlurAdvanced = parseInt(blurAdvancedSliderMain.value);
                        
                        redrawEditorCanvas();
                    });
                });
            };

            // Event listeners for tool buttons
            toolZoomBtn.addEventListener('click', () => setTool('zoom'));
            toolCaptionBtn.addEventListener('click', () => setTool('caption'));
            toolBackgroundBtn.addEventListener('click', () => setTool('background'));
            toolAdvancedBtn.addEventListener('click', () => setTool('advanced'));

            // Event listeners for zoom controls
            zoomSlider.addEventListener('input', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempZoom = parseInt(zoomSlider.value);
                zoomValue.textContent = `${image.tempZoom}%`;
                redrawEditorCanvas();
            });

            zoomInBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempZoom = Math.min(parseInt(image.tempZoom) + 10, 300);
                zoomSlider.value = image.tempZoom;
                zoomValue.textContent = `${image.tempZoom}%`;
                redrawEditorCanvas();
            });

            zoomOutBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempZoom = Math.max(parseInt(image.tempZoom) - 10, 50);
                zoomSlider.value = image.tempZoom;
                zoomValue.textContent = `${image.tempZoom}%`;
                redrawEditorCanvas();
            });

            zoomResetBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempZoom = 100;
                zoomSlider.value = image.tempZoom;
                zoomValue.textContent = `${image.tempZoom}%`;
                redrawEditorCanvas();
            });

            saveZoomBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.zoom = image.tempZoom;
                setTool(null);
                renderImages();
            });

            discardZoomBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempZoom = image.zoom || 100;
                redrawEditorCanvas();
                setTool(null);
            });

            // Applies the blur effect and updates the image data
            const applyBlur = (imageElement, imageObject, blurRadius) => {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = imageElement.width + BLUR_PADDING;
                tempCanvas.height = imageElement.height + BLUR_PADDING;
                const ctx = tempCanvas.getContext('2d');
                ctx.filter = `blur(${blurRadius}px)`;
                ctx.drawImage(imageElement, BLUR_PADDING / 2, BLUR_PADDING / 2, imageElement.width, imageElement.height);
                imageObject.blurredUrl = tempCanvas.toDataURL('image/png');
            };

            // Save and Discard actions for each tool
            saveCaptionBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.captions = JSON.parse(JSON.stringify(image.tempCaptions));
                image.drawings = JSON.parse(JSON.stringify(image.tempDrawings));
                setTool(null);
                renderImages();
            });

            discardCaptionBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempCaptions = JSON.parse(JSON.stringify(image.captions));
                image.tempDrawings = JSON.parse(JSON.stringify(image.drawings || []));
                setTool(null);
                redrawEditorCanvas();
            });

            saveBackgroundBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.blurRadius = image.tempBlurRadius;
                image.backgroundSize = image.tempBackgroundSize;
                image.matrix = image.tempMatrix;
                image.saturation = image.tempSaturation;
                image.brightness = image.tempBrightness;
                image.contrast = image.tempContrast;
                image.sharpness = image.tempSharpness;
                image.blurAdvanced = image.tempBlurAdvanced;
                applyBlur(image.imgElement, image, image.blurRadius);
                setTool(null);
                renderImages();
            });

            discardBackgroundBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempBlurRadius = image.blurRadius;
                image.tempBackgroundSize = image.backgroundSize;
                image.tempMatrix = image.matrix;
                image.tempSaturation = image.saturation;
                image.tempBrightness = image.brightness;
                image.tempContrast = image.contrast;
                image.tempSharpness = image.sharpness;
                image.tempBlurAdvanced = image.blurAdvanced;
                applyBlur(image.imgElement, image, image.tempBlurRadius);
                setTool(null);
                redrawEditorCanvas();
            });

            saveAdvancedBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.matrix = image.tempMatrix;
                image.saturation = image.tempSaturation;
                image.brightness = image.tempBrightness;
                image.contrast = image.tempContrast;
                image.sharpness = image.tempSharpness;
                image.blurAdvanced = image.tempBlurAdvanced;
                setTool(null);
                renderImages();
            });

            discardAdvancedBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.tempMatrix = image.matrix;
                image.tempSaturation = image.saturation;
                image.tempBrightness = image.brightness;
                image.tempContrast = image.contrast;
                image.tempSharpness = image.sharpness;
                image.tempBlurAdvanced = image.blurAdvanced;
                setTool(null);
                redrawEditorCanvas();
            });

            // Back button simply closes the modal without saving
            backBtn.addEventListener('click', () => {
                editModal.classList.add('hidden');
                window.removeEventListener('resize', resizeCanvasAndDraw);
                renderImages();
            });

            // Next image button
            nextImageBtn.addEventListener('click', () => {
                // Salvar as alterações da imagem atual
                const image = uploadedImages[currentImageIndex];
                image.captions = JSON.parse(JSON.stringify(image.tempCaptions));
                image.drawings = JSON.parse(JSON.stringify(image.tempDrawings));
                image.blurRadius = image.tempBlurRadius;
                image.backgroundSize = image.tempBackgroundSize;
                image.zoom = image.tempZoom;
                image.matrix = image.tempMatrix;
                image.saturation = image.tempSaturation;
                image.brightness = image.tempBrightness;
                image.contrast = image.tempContrast;
                image.sharpness = image.tempSharpness;
                image.blurAdvanced = image.tempBlurAdvanced;
                
                // Ir para a próxima imagem
                currentImageIndex = (currentImageIndex + 1) % uploadedImages.length;
                openEditModal(uploadedImages[currentImageIndex]);
            });

            // Reset all button
            resetAllBtn.addEventListener('click', () => {
                if (confirm('Tem certeza que deseja resetar todas as alterações desta imagem?')) {
                    const image = uploadedImages[currentImageIndex];
                    // Restaurar os valores originais
                    image.crop = { x: 0, y: 0, width: image.imgElement.width, height: image.imgElement.height };
                    image.zoom = 100;
                    image.captions = [];
                    image.drawings = [];
                    image.blurRadius = DEFAULT_BLUR;
                    image.backgroundSize = DEFAULT_BG_SIZE;
                    image.matrix = 0;
                    image.saturation = 0;
                    image.brightness = 0;
                    image.contrast = 0;
                    image.sharpness = 0;
                    image.blurAdvanced = 0;
                    // Recriar a imagem cortada e blurred
                    image.croppedUrl = image.originalUrl;
                    applyBlur(image.imgElement, image, DEFAULT_BLUR);
                    // Fechar o modal e recarregar
                    editModal.classList.add('hidden');
                    renderImages();
                }
            });

            // Reset caption button
            resetCaptionBtn.addEventListener('click', () => {
                if (confirm('Tem certeza que deseja resetar todas as legendas?')) {
                    const image = uploadedImages[currentImageIndex];
                    image.tempCaptions = [];
                    redrawEditorCanvas();
                }
            });

            // Event listener for image upload
            imageUpload.addEventListener('change', (event) => {
                const files = event.target.files;
                if (files.length > 0) {
                    loadingOverlay.classList.remove('hidden');
                    loadingText.textContent = 'Carregando imagens...';
                    
                    let loadedCount = 0;
                    const totalFiles = files.length;
                    
                    Array.from(files).forEach(file => {
                        if (!file.type.match('image.*')) {
                            loadedCount++;
                            if (loadedCount === totalFiles) {
                                loadingOverlay.classList.add('hidden');
                            }
                            statusMessage.textContent = 'Por favor, selecione apenas arquivos de imagem.';
                            return;
                        }
                        
                        if (file.size > 10 * 1024 * 1024) {
                            loadedCount++;
                            if (loadedCount === totalFiles) {
                                loadingOverlay.classList.add('hidden');
                            }
                            statusMessage.textContent = 'Imagem muito grande. Por favor, selecione imagens menores que 10MB.';
                            return;
                        }
                        
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                let isRotated = false;
                                let processedImg = img;
                                let imgWidth = img.width;
                                let imgHeight = img.height;

                                if (imgWidth - imgHeight >= 250) {
                                    const canvas = document.createElement('canvas');
                                    const ctx = canvas.getContext('2d');
                                    
                                    canvas.width = imgHeight;
                                    canvas.height = imgWidth;
                                    
                                    ctx.translate(canvas.width / 2, canvas.height / 2);
                                    ctx.rotate(90 * Math.PI / 180);
                                    ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);

                                    processedImg = new Image();
                                    processedImg.src = canvas.toDataURL('image/png');
                                    
                                    isRotated = true;
                                    imgWidth = processedImg.width;
                                    imgHeight = processedImg.height;
                                }

                                const newImage = {
                                    id: Date.now() + Math.random(),
                                    originalUrl: e.target.result,
                                    imgElement: processedImg,
                                    croppedUrl: processedImg.src,
                                    crop: { x: 0, y: 0, width: imgWidth, height: imgHeight },
                                    blurredUrl: null,
                                    blurRadius: DEFAULT_BLUR,
                                    backgroundSize: DEFAULT_BG_SIZE,
                                    zoom: 100,
                                    captions: [],
                                    drawings: [],
                                    matrix: 0,
                                    saturation: 0,
                                    brightness: 0,
                                    contrast: 0,
                                    sharpness: 0,
                                    blurAdvanced: 0,
                                    isRotated: isRotated,
                                    tempCaptions: [],
                                    tempDrawings: [],
                                    tempBlurRadius: DEFAULT_BLUR,
                                    tempBackgroundSize: DEFAULT_BG_SIZE,
                                    tempZoom: 100,
                                    tempMatrix: 0,
                                    tempSaturation: 0,
                                    tempBrightness: 0,
                                    tempContrast: 0,
                                    tempSharpness: 0,
                                    tempBlurAdvanced: 0,
                                };
                                applyBlur(processedImg, newImage, DEFAULT_BLUR);
                                
                                if (newImage.isRotated) {
                                    uploadedImages.unshift(newImage);
                                } else {
                                    uploadedImages.push(newImage);
                                }

                                loadedCount++;
                                if (loadedCount === totalFiles) {
                                    loadingOverlay.classList.add('hidden');
                                    renderImages();
                                    updateExportButtonState();
                                    statusMessage.textContent = `${totalFiles} imagem(ns) carregada(s) com sucesso!`;
                                }
                            };
                            img.src = e.target.result;
                        };
                        reader.readAsDataURL(file);
                    });
                }
            });

            // Event listener for the "Clear All" button
            clearAllBtn.addEventListener('click', () => {
                if (uploadedImages.length === 0) return;
                
                if (confirm('Tem certeza que deseja remover todas as imagens?')) {
                    uploadedImages = [];
                    imageGallery.innerHTML = '';
                    previewGallery.innerHTML = '';
                    updateExportButtonState();
                    statusMessage.textContent = 'Todas as imagens foram removidas.';
                }
            });

            // Background upload functionality
            backgroundUploadBtn.addEventListener('click', () => {
                backgroundUpload.click();
            });

            backgroundUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file && file.type.match('image.*')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const image = uploadedImages[currentImageIndex];
                            image.blurredUrl = e.target.result;
                            redrawEditorCanvas();
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });

            // Use same photo as background
            useSamePhotoBtn.addEventListener('click', () => {
                const image = uploadedImages[currentImageIndex];
                image.blurredUrl = image.originalUrl;
                redrawEditorCanvas();
            });

            // Lógica para o novo botão de pré-visualização completa
            fullPreviewBtn.addEventListener('click', () => {
                if (uploadedImages.length === 0) return;

                fullPreviewModal.classList.remove('hidden');
                fullPreviewArea.innerHTML = '';
                currentPageIndex = 0;

                const orientation = 'landscape';
                const config = gridConfigs[gridType];
                const pageTotalWidth = A4_WIDTH_PX_LANDSCAPE;
                const pageTotalHeight = A4_HEIGHT_PX_LANDSCAPE;
                const IMAGES_PER_PAGE = config.cols * config.rows;
                const totalPages = Math.ceil(uploadedImages.length / IMAGES_PER_PAGE);

                if (totalPages > 1) {
                    fullPreviewNav.classList.remove('hidden');
                    prevPageBtn.disabled = currentPageIndex === 0;
                    nextPageBtn.disabled = currentPageIndex === totalPages - 1;
                } else {
                    fullPreviewNav.classList.add('hidden');
                }
                
                pageIndicator.textContent = `Página ${currentPageIndex + 1} de ${totalPages}`;

                loadingOverlay.classList.remove('hidden');
                loadingText.textContent = 'Gerando pré-visualização...';

                let renderPromiseChain = Promise.resolve();
                for (let i = 0; i < totalPages; i++) {
                    renderPromiseChain = renderPromiseChain.then(() => {
                        const previewCanvas = document.createElement('canvas');
                        previewCanvas.width = pageTotalWidth;
                        previewCanvas.height = pageTotalHeight;
                        const previewCtx = previewCanvas.getContext('2d');
                        previewCtx.fillStyle = '#FFFFFF';
                        previewCtx.fillRect(0, 0, pageTotalWidth, pageTotalHeight);

                        return new Promise((resolvePage) => {
                            let drawPromiseChain = Promise.resolve();
                            const startImageIndex = i * IMAGES_PER_PAGE;
                            const endImageIndex = Math.min(startImageIndex + IMAGES_PER_PAGE, uploadedImages.length);

                            for (let j = startImageIndex; j < endImageIndex; j++) {
                                drawPromiseChain = drawPromiseChain.then(() => {
                                    const imageInPageIndex = j % IMAGES_PER_PAGE;
                                    const col = imageInPageIndex % config.cols;
                                    const row = Math.floor(imageInPageIndex / config.cols);

                                    const xPos = config.horizontalSpacing + col * (config.imageWidth + config.horizontalSpacing);
                                    const yPos = config.verticalSpacing + row * (config.imageHeight + config.verticalSpacing);

                                    const compositeCanvas = document.createElement('canvas');
                                    compositeCanvas.width = config.imageWidth;
                                    compositeCanvas.height = config.imageHeight;
                                    const compositeCtx = compositeCanvas.getContext('2d');

                                    return drawCompositeImage(compositeCtx, uploadedImages[j], config).then(() => {
                                        previewCtx.drawImage(compositeCanvas, xPos, yPos);
                                    });
                                });
                            }
                            drawPromiseChain.then(() => {
                                const previewImage = new Image();
                                previewImage.src = previewCanvas.toDataURL('image/png');
                                previewImage.className = 'preview-page';
                                fullPreviewArea.appendChild(previewImage);
                                resolvePage();
                            });
                        });
                    });
                }
                
                renderPromiseChain.then(() => {
                    loadingOverlay.classList.add('hidden');
                });
            });

            closePreviewBtn.addEventListener('click', () => {
                fullPreviewModal.classList.add('hidden');
            });
            
            // Navegação entre pranchetas
            prevPageBtn.addEventListener('click', () => {
                const config = gridConfigs[gridType];
                const totalPages = Math.ceil(uploadedImages.length / (config.cols * config.rows));
                if (currentPageIndex > 0) {
                    currentPageIndex--;
                    pageIndicator.textContent = `Página ${currentPageIndex + 1} de ${totalPages}`;
                    nextPageBtn.disabled = false;
                    if (currentPageIndex === 0) {
                        prevPageBtn.disabled = true;
                    }
                }
            });

            nextPageBtn.addEventListener('click', () => {
                const config = gridConfigs[gridType];
                const totalPages = Math.ceil(uploadedImages.length / (config.cols * config.rows));
                if (currentPageIndex < totalPages - 1) {
                    currentPageIndex++;
                    pageIndicator.textContent = `Página ${currentPageIndex + 1} de ${totalPages}`;
                    prevPageBtn.disabled = false;
                    if (currentPageIndex === totalPages - 1) {
                        nextPageBtn.disabled = true;
                    }
                }
            });

            // Common export function
            const exportDocument = (orientation, format) => {
                const config = gridConfigs[gridType];
                const IMAGES_PER_PAGE = config.cols * config.rows;
                const totalPages = Math.ceil(uploadedImages.length / IMAGES_PER_PAGE);

                loadingOverlay.classList.remove('hidden');
                loadingText.textContent = `Gerando ${format.toUpperCase()}... Por favor, aguarde.`;
                
                statusMessage.textContent = `Gerando ${format.toUpperCase()}... Por favor, aguarde.`;
                exportLandscapeBtn.disabled = true;
                exportLandscapeJpgBtn.disabled = true;

                const doc = (format === 'pdf') ? new jsPDF({
                    orientation: orientation,
                    unit: 'px',
                    format: [A4_WIDTH_PX_LANDSCAPE, A4_HEIGHT_PX_LANDSCAPE]
                }) : null;
                
                let processedImages = 0;

                function processPage(pageIndex) {
                    if (pageIndex >= totalPages) {
                         if (format === 'pdf') {
                            doc.save(`documento_imagens_${orientation}.pdf`);
                        }
                        statusMessage.textContent = `${format.toUpperCase()} gerado com sucesso!`;
                        exportLandscapeBtn.disabled = false;
                        exportLandscapeJpgBtn.disabled = false;
                        loadingOverlay.classList.add('hidden');
                        return;
                    }

                    const pageCanvas = document.createElement('canvas');
                    pageCanvas.width = A4_WIDTH_PX_LANDSCAPE;
                    pageCanvas.height = A4_HEIGHT_PX_LANDSCAPE;
                    const pageCtx = pageCanvas.getContext('2d');
                    pageCtx.fillStyle = '#FFFFFF';
                    pageCtx.fillRect(0, 0, A4_WIDTH_PX_LANDSCAPE, A4_HEIGHT_PX_LANDSCAPE);

                    const startImageIndex = pageIndex * IMAGES_PER_PAGE;
                    const endImageIndex = Math.min(startImageIndex + IMAGES_PER_PAGE, uploadedImages.length);

                    let drawPromiseChain = Promise.resolve();
                    for (let i = startImageIndex; i < endImageIndex; i++) {
                        drawPromiseChain = drawPromiseChain.then(() => {
                            const imageInPageIndex = i % IMAGES_PER_PAGE;
                            const col = imageInPageIndex % config.cols;
                            const row = Math.floor(imageInPageIndex / config.cols);
                            
                            let xPos = config.horizontalSpacing + col * (config.imageWidth + config.horizontalSpacing);
                            let yPos = config.verticalSpacing + row * (config.imageHeight + config.verticalSpacing);

                            const compositeCanvas = document.createElement('canvas');
                            compositeCanvas.width = config.imageWidth;
                            compositeCanvas.height = config.imageHeight;
                            const compositeCtx = compositeCanvas.getContext('2d');

                            return drawCompositeImage(compositeCtx, uploadedImages[i], config)
                                .then(() => {
                                    pageCtx.drawImage(compositeCanvas, xPos, yPos);
                                });
                        });
                    }

                    drawPromiseChain.then(() => {
                        const dataUrl = pageCanvas.toDataURL(`image/${format === 'jpg' ? 'jpeg' : 'png'}`, 1.0);
                        if (format === 'pdf') {
                            if (pageIndex > 0) doc.addPage();
                            doc.addImage(dataUrl, 'PNG', 0, 0, A4_WIDTH_PX_LANDSCAPE, A4_HEIGHT_PX_LANDSCAPE);
                        } else {
                            const link = document.createElement('a');
                            link.href = dataUrl;
                            link.download = `documento_imagens_${orientation}_pagina_${pageIndex + 1}.jpg`;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                        }
                        processPage(pageIndex + 1);
                    }).catch(err => {
                        console.error('Failed to process image:', err);
                        statusMessage.textContent = `Erro ao carregar uma imagem para exportação.`;
                        exportLandscapeBtn.disabled = false;
                        exportLandscapeJpgBtn.disabled = false;
                        loadingOverlay.classList.add('hidden');
                    });
                }
                processPage(0);
            };

            // Event listeners for the export buttons
            exportLandscapeBtn.addEventListener('click', () => exportDocument('landscape', 'pdf'));
            exportLandscapeJpgBtn.addEventListener('click', () => exportDocument('landscape', 'jpg'));

            // Event listeners for the new modal export buttons
            modalExportLandscapeBtn.addEventListener('click', () => {
                exportDocument('landscape', 'pdf');
                fullPreviewModal.classList.add('hidden');
            });
            modalExportLandscapeJpgBtn.addEventListener('click', () => {
                exportDocument('landscape', 'jpg');
                fullPreviewModal.classList.add('hidden');
            });

            // Implementação do Drag & Drop
            const uploadSectionElement = document.getElementById('upload-section');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadSectionElement.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadSectionElement.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                uploadSectionElement.addEventListener(eventName, unhighlight, false);
            });
            
            function highlight() {
                uploadSectionElement.classList.add('drag-over');
            }
            
            function unhighlight() {
                uploadSectionElement.classList.remove('drag-over');
            }
            
            uploadSectionElement.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    imageUpload.files = files;
                    const event = new Event('change');
                    imageUpload.dispatchEvent(event);
                }
            }

            // Funções para o editor de legendas
            captionColorInput.addEventListener('input', () => {
                textColorPreview.style.backgroundColor = captionColorInput.value;
            });
            
            captionOutlineColorInput.addEventListener('input', () => {
                outlineColorPreview.style.backgroundColor = captionOutlineColorInput.value;
            });
            
            // Alinhamento de texto
            alignmentButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const align = btn.dataset.align;
                    if (uploadedImages[currentImageIndex].tempCaptions.length > 0 && selectedCaptionIndex >= 0) {
                        uploadedImages[currentImageIndex].tempCaptions[selectedCaptionIndex].align = align;
                        redrawEditorCanvas();
                    }
                });
            });
            
            // Seleção de tipo de grade
            gridTypeSelect.addEventListener('change', () => {
                gridType = gridTypeSelect.value;
                // Atualizar seleção visual
                gridOptions.forEach(option => {
                    if (option.dataset.grid === gridType) {
                        option.classList.add('selected');
                    } else {
                        option.classList.remove('selected');
                    }
                });
                renderImages();
            });
            
            gridOptions.forEach(option => {
                option.addEventListener('click', () => {
                    gridType = option.dataset.grid;
                    gridTypeSelect.value = gridType;
                    
                    // Atualizar seleção visual
                    gridOptions.forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    
                    renderImages();
                });
            });

            // Eventos para arrastar legendas
            editorCanvas.addEventListener('mousedown', (e) => {
                if (currentTool === 'caption' && uploadedImages[currentImageIndex].tempCaptions.length > 0) {
                    const rect = editorCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Calcular escala
                    const image = uploadedImages[currentImageIndex];
                    const { drawWidth, drawHeight, offsetX, offsetY } = getProportionalContainDimensions(
                        image.imgElement.width, 
                        image.imgElement.height, 
                        editorCanvas.width, 
                        editorCanvas.height
                    );
                    const scale = drawWidth / image.imgElement.width;
                    
                    // Verificar se o clique foi em uma legenda
                    for (let i = 0; i < image.tempCaptions.length; i++) {
                        const caption = image.tempCaptions[i];
                        const xPos = offsetX + caption.x * scale;
                        const yPos = offsetY + caption.y * scale;
                        
                        editorCtx.font = `${caption.size * scale}px ${caption.font}`;
                        const textWidth = editorCtx.measureText(caption.text).width;
                        
                        if (
                            mouseX >= xPos - 5 && 
                            mouseX <= xPos + textWidth + 5 && 
                            mouseY >= yPos - caption.size * scale - 5 && 
                            mouseY <= yPos + 5
                        ) {
                            isDragging = true;
                            selectedCaptionIndex = i;
                            dragOffset.x = mouseX - xPos;
                            dragOffset.y = mouseY - yPos;
                            
                            // Atualizar controles com a legenda selecionada
                            captionTextInput.value = caption.text;
                            captionColorInput.value = caption.color;
                            captionOutlineColorInput.value = caption.outlineColor;
                            captionSizeSlider.value = caption.size;
                            captionSizeValueText.textContent = `${caption.size} px`;
                            captionStrokeSlider.value = caption.strokeWidth;
                            captionStrokeValueText.textContent = `${caption.strokeWidth} px`;
                            captionFontSelect.value = caption.font;
                            
                            redrawEditorCanvas();
                            break;
                        }
                    }
                }
            });
            
            editorCanvas.addEventListener('mousemove', (e) => {
                if (isDragging && selectedCaptionIndex >= 0) {
                    const rect = editorCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    // Calcular escala
                    const image = uploadedImages[currentImageIndex];
                    const { drawWidth, drawHeight, offsetX, offsetY } = getProportionalContainDimensions(
                        image.imgElement.width, 
                        image.imgElement.height, 
                        editorCanvas.width, 
                        editorCanvas.height
                    );
                    const scale = image.imgElement.width / drawWidth;
                    
                    // Atualizar posição da legenda
                    const caption = image.tempCaptions[selectedCaptionIndex];
                    caption.x = (mouseX - offsetX - dragOffset.x) * scale;
                    caption.y = (mouseY - offsetY - dragOffset.y) * scale;
                    
                    redrawEditorCanvas();
                }
            });
            
            editorCanvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            editorCanvas.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            // Eventos de toque para dispositivos móveis
            editorCanvas.addEventListener('touchstart', (e) => {
                if (currentTool === 'caption' && uploadedImages[currentImageIndex].tempCaptions.length > 0) {
                    e.preventDefault();
                    const rect = editorCanvas.getBoundingClientRect();
                    const touchX = e.touches[0].clientX - rect.left;
                    const touchY = e.touches[0].clientY - rect.top;
                    
                    // Calcular escala
                    const image = uploadedImages[currentImageIndex];
                    const { drawWidth, drawHeight, offsetX, offsetY } = getProportionalContainDimensions(
                        image.imgElement.width, 
                        image.imgElement.height, 
                        editorCanvas.width, 
                        editorCanvas.height
                    );
                    const scale = drawWidth / image.imgElement.width;
                    
                    // Verificar se o toque foi em uma legenda
                    for (let i = 0; i < image.tempCaptions.length; i++) {
                        const caption = image.tempCaptions[i];
                        const xPos = offsetX + caption.x * scale;
                        const yPos = offsetY + caption.y * scale;
                        
                        editorCtx.font = `${caption.size * scale}px ${caption.font}`;
                        const textWidth = editorCtx.measureText(caption.text).width;
                        
                        if (
                            touchX >= xPos - 5 && 
                            touchX <= xPos + textWidth + 5 && 
                            touchY >= yPos - caption.size * scale - 5 && 
                            touchY <= yPos + 5
                        ) {
                            isDragging = true;
                            selectedCaptionIndex = i;
                            dragOffset.x = touchX - xPos;
                            dragOffset.y = touchY - yPos;
                            
                            // Atualizar controles com a legenda selecionada
                            captionTextInput.value = caption.text;
                            captionColorInput.value = caption.color;
                            captionOutlineColorInput.value = caption.outlineColor;
                            captionSizeSlider.value = caption.size;
                            captionSizeValueText.textContent = `${caption.size} px`;
                            captionStrokeSlider.value = caption.strokeWidth;
                            captionStrokeValueText.textContent = `${caption.strokeWidth} px`;
                            captionFontSelect.value = caption.font;
                            
                            redrawEditorCanvas();
                            break;
                        }
                    }
                }
            });
            
            editorCanvas.addEventListener('touchmove', (e) => {
                if (isDragging && selectedCaptionIndex >= 0) {
                    e.preventDefault();
                    const rect = editorCanvas.getBoundingClientRect();
                    const touchX = e.touches[0].clientX - rect.left;
                    const touchY = e.touches[0].clientY - rect.top;
                    
                    // Calcular escala
                    const image = uploadedImages[currentImageIndex];
                    const { drawWidth, drawHeight, offsetX, offsetY } = getProportionalContainDimensions(
                        image.imgElement.width, 
                        image.imgElement.height, 
                        editorCanvas.width, 
                        editorCanvas.height
                    );
                    const scale = image.imgElement.width / drawWidth;
                    
                    // Atualizar posição da legenda
                    const caption = image.tempCaptions[selectedCaptionIndex];
                    caption.x = (touchX - offsetX - dragOffset.x) * scale;
                    caption.y = (touchY - offsetY - dragOffset.y) * scale;
                    
                    redrawEditorCanvas();
                }
            });
            
            editorCanvas.addEventListener('touchend', () => {
                isDragging = false;
            });

            // Implementar Ctrl+Z para desfazer
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                    e.preventDefault();
                    undoLastAction();
                }
            });

            // Inicialização da aplicação
            updateExportButtonState();
        };
    </script>
</body>
</html>
